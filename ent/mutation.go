// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sastoj/ent/contest"
	"sastoj/ent/contestresult"
	"sastoj/ent/group"
	"sastoj/ent/loginsession"
	"sastoj/ent/predicate"
	"sastoj/ent/problem"
	"sastoj/ent/problemtype"
	"sastoj/ent/schema"
	"sastoj/ent/submission"
	"sastoj/ent/submissioncase"
	"sastoj/ent/submissionsubtask"
	"sastoj/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeContest           = "Contest"
	TypeContestResult     = "ContestResult"
	TypeGroup             = "Group"
	TypeLoginSession      = "LoginSession"
	TypeProblem           = "Problem"
	TypeProblemType       = "ProblemType"
	TypeSubmission        = "Submission"
	TypeSubmissionCase    = "SubmissionCase"
	TypeSubmissionSubtask = "SubmissionSubtask"
	TypeUser              = "User"
)

// ContestMutation represents an operation that mutates the Contest nodes in the graph.
type ContestMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	title                  *string
	description            *string
	state                  *contest.State
	_type                  *int16
	add_type               *int16
	start_time             *time.Time
	end_time               *time.Time
	language               *string
	extra_time             *int16
	addextra_time          *int16
	create_time            *time.Time
	clearedFields          map[string]struct{}
	problems               map[int64]struct{}
	removedproblems        map[int64]struct{}
	clearedproblems        bool
	contestants            map[int64]struct{}
	removedcontestants     map[int64]struct{}
	clearedcontestants     bool
	managers               map[int64]struct{}
	removedmanagers        map[int64]struct{}
	clearedmanagers        bool
	contest_results        map[int]struct{}
	removedcontest_results map[int]struct{}
	clearedcontest_results bool
	done                   bool
	oldValue               func(context.Context) (*Contest, error)
	predicates             []predicate.Contest
}

var _ ent.Mutation = (*ContestMutation)(nil)

// contestOption allows management of the mutation configuration using functional options.
type contestOption func(*ContestMutation)

// newContestMutation creates new mutation for the Contest entity.
func newContestMutation(c config, op Op, opts ...contestOption) *ContestMutation {
	m := &ContestMutation{
		config:        c,
		op:            op,
		typ:           TypeContest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestID sets the ID field of the mutation.
func withContestID(id int64) contestOption {
	return func(m *ContestMutation) {
		var (
			err   error
			once  sync.Once
			value *Contest
		)
		m.oldValue = func(ctx context.Context) (*Contest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContest sets the old Contest of the mutation.
func withContest(node *Contest) contestOption {
	return func(m *ContestMutation) {
		m.oldValue = func(context.Context) (*Contest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contest entities.
func (m *ContestMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ContestMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContestMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ContestMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ContestMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContestMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ContestMutation) ResetDescription() {
	m.description = nil
}

// SetState sets the "state" field.
func (m *ContestMutation) SetState(c contest.State) {
	m.state = &c
}

// State returns the value of the "state" field in the mutation.
func (m *ContestMutation) State() (r contest.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldState(ctx context.Context) (v contest.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *ContestMutation) ResetState() {
	m.state = nil
}

// SetType sets the "type" field.
func (m *ContestMutation) SetType(i int16) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContestMutation) GetType() (r int16, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldType(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ContestMutation) AddType(i int16) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ContestMutation) AddedType() (r int16, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ContestMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStartTime sets the "start_time" field.
func (m *ContestMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ContestMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ContestMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ContestMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ContestMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ContestMutation) ResetEndTime() {
	m.end_time = nil
}

// SetLanguage sets the "language" field.
func (m *ContestMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *ContestMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *ContestMutation) ResetLanguage() {
	m.language = nil
}

// SetExtraTime sets the "extra_time" field.
func (m *ContestMutation) SetExtraTime(i int16) {
	m.extra_time = &i
	m.addextra_time = nil
}

// ExtraTime returns the value of the "extra_time" field in the mutation.
func (m *ContestMutation) ExtraTime() (r int16, exists bool) {
	v := m.extra_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraTime returns the old "extra_time" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldExtraTime(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraTime: %w", err)
	}
	return oldValue.ExtraTime, nil
}

// AddExtraTime adds i to the "extra_time" field.
func (m *ContestMutation) AddExtraTime(i int16) {
	if m.addextra_time != nil {
		*m.addextra_time += i
	} else {
		m.addextra_time = &i
	}
}

// AddedExtraTime returns the value that was added to the "extra_time" field in this mutation.
func (m *ContestMutation) AddedExtraTime() (r int16, exists bool) {
	v := m.addextra_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExtraTime resets all changes to the "extra_time" field.
func (m *ContestMutation) ResetExtraTime() {
	m.extra_time = nil
	m.addextra_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *ContestMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ContestMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ContestMutation) ResetCreateTime() {
	m.create_time = nil
}

// AddProblemIDs adds the "problems" edge to the Problem entity by ids.
func (m *ContestMutation) AddProblemIDs(ids ...int64) {
	if m.problems == nil {
		m.problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.problems[ids[i]] = struct{}{}
	}
}

// ClearProblems clears the "problems" edge to the Problem entity.
func (m *ContestMutation) ClearProblems() {
	m.clearedproblems = true
}

// ProblemsCleared reports if the "problems" edge to the Problem entity was cleared.
func (m *ContestMutation) ProblemsCleared() bool {
	return m.clearedproblems
}

// RemoveProblemIDs removes the "problems" edge to the Problem entity by IDs.
func (m *ContestMutation) RemoveProblemIDs(ids ...int64) {
	if m.removedproblems == nil {
		m.removedproblems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.problems, ids[i])
		m.removedproblems[ids[i]] = struct{}{}
	}
}

// RemovedProblems returns the removed IDs of the "problems" edge to the Problem entity.
func (m *ContestMutation) RemovedProblemsIDs() (ids []int64) {
	for id := range m.removedproblems {
		ids = append(ids, id)
	}
	return
}

// ProblemsIDs returns the "problems" edge IDs in the mutation.
func (m *ContestMutation) ProblemsIDs() (ids []int64) {
	for id := range m.problems {
		ids = append(ids, id)
	}
	return
}

// ResetProblems resets all changes to the "problems" edge.
func (m *ContestMutation) ResetProblems() {
	m.problems = nil
	m.clearedproblems = false
	m.removedproblems = nil
}

// AddContestantIDs adds the "contestants" edge to the Group entity by ids.
func (m *ContestMutation) AddContestantIDs(ids ...int64) {
	if m.contestants == nil {
		m.contestants = make(map[int64]struct{})
	}
	for i := range ids {
		m.contestants[ids[i]] = struct{}{}
	}
}

// ClearContestants clears the "contestants" edge to the Group entity.
func (m *ContestMutation) ClearContestants() {
	m.clearedcontestants = true
}

// ContestantsCleared reports if the "contestants" edge to the Group entity was cleared.
func (m *ContestMutation) ContestantsCleared() bool {
	return m.clearedcontestants
}

// RemoveContestantIDs removes the "contestants" edge to the Group entity by IDs.
func (m *ContestMutation) RemoveContestantIDs(ids ...int64) {
	if m.removedcontestants == nil {
		m.removedcontestants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.contestants, ids[i])
		m.removedcontestants[ids[i]] = struct{}{}
	}
}

// RemovedContestants returns the removed IDs of the "contestants" edge to the Group entity.
func (m *ContestMutation) RemovedContestantsIDs() (ids []int64) {
	for id := range m.removedcontestants {
		ids = append(ids, id)
	}
	return
}

// ContestantsIDs returns the "contestants" edge IDs in the mutation.
func (m *ContestMutation) ContestantsIDs() (ids []int64) {
	for id := range m.contestants {
		ids = append(ids, id)
	}
	return
}

// ResetContestants resets all changes to the "contestants" edge.
func (m *ContestMutation) ResetContestants() {
	m.contestants = nil
	m.clearedcontestants = false
	m.removedcontestants = nil
}

// AddManagerIDs adds the "managers" edge to the Group entity by ids.
func (m *ContestMutation) AddManagerIDs(ids ...int64) {
	if m.managers == nil {
		m.managers = make(map[int64]struct{})
	}
	for i := range ids {
		m.managers[ids[i]] = struct{}{}
	}
}

// ClearManagers clears the "managers" edge to the Group entity.
func (m *ContestMutation) ClearManagers() {
	m.clearedmanagers = true
}

// ManagersCleared reports if the "managers" edge to the Group entity was cleared.
func (m *ContestMutation) ManagersCleared() bool {
	return m.clearedmanagers
}

// RemoveManagerIDs removes the "managers" edge to the Group entity by IDs.
func (m *ContestMutation) RemoveManagerIDs(ids ...int64) {
	if m.removedmanagers == nil {
		m.removedmanagers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.managers, ids[i])
		m.removedmanagers[ids[i]] = struct{}{}
	}
}

// RemovedManagers returns the removed IDs of the "managers" edge to the Group entity.
func (m *ContestMutation) RemovedManagersIDs() (ids []int64) {
	for id := range m.removedmanagers {
		ids = append(ids, id)
	}
	return
}

// ManagersIDs returns the "managers" edge IDs in the mutation.
func (m *ContestMutation) ManagersIDs() (ids []int64) {
	for id := range m.managers {
		ids = append(ids, id)
	}
	return
}

// ResetManagers resets all changes to the "managers" edge.
func (m *ContestMutation) ResetManagers() {
	m.managers = nil
	m.clearedmanagers = false
	m.removedmanagers = nil
}

// AddContestResultIDs adds the "contest_results" edge to the ContestResult entity by ids.
func (m *ContestMutation) AddContestResultIDs(ids ...int) {
	if m.contest_results == nil {
		m.contest_results = make(map[int]struct{})
	}
	for i := range ids {
		m.contest_results[ids[i]] = struct{}{}
	}
}

// ClearContestResults clears the "contest_results" edge to the ContestResult entity.
func (m *ContestMutation) ClearContestResults() {
	m.clearedcontest_results = true
}

// ContestResultsCleared reports if the "contest_results" edge to the ContestResult entity was cleared.
func (m *ContestMutation) ContestResultsCleared() bool {
	return m.clearedcontest_results
}

// RemoveContestResultIDs removes the "contest_results" edge to the ContestResult entity by IDs.
func (m *ContestMutation) RemoveContestResultIDs(ids ...int) {
	if m.removedcontest_results == nil {
		m.removedcontest_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contest_results, ids[i])
		m.removedcontest_results[ids[i]] = struct{}{}
	}
}

// RemovedContestResults returns the removed IDs of the "contest_results" edge to the ContestResult entity.
func (m *ContestMutation) RemovedContestResultsIDs() (ids []int) {
	for id := range m.removedcontest_results {
		ids = append(ids, id)
	}
	return
}

// ContestResultsIDs returns the "contest_results" edge IDs in the mutation.
func (m *ContestMutation) ContestResultsIDs() (ids []int) {
	for id := range m.contest_results {
		ids = append(ids, id)
	}
	return
}

// ResetContestResults resets all changes to the "contest_results" edge.
func (m *ContestMutation) ResetContestResults() {
	m.contest_results = nil
	m.clearedcontest_results = false
	m.removedcontest_results = nil
}

// Where appends a list predicates to the ContestMutation builder.
func (m *ContestMutation) Where(ps ...predicate.Contest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contest).
func (m *ContestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, contest.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, contest.FieldDescription)
	}
	if m.state != nil {
		fields = append(fields, contest.FieldState)
	}
	if m._type != nil {
		fields = append(fields, contest.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, contest.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, contest.FieldEndTime)
	}
	if m.language != nil {
		fields = append(fields, contest.FieldLanguage)
	}
	if m.extra_time != nil {
		fields = append(fields, contest.FieldExtraTime)
	}
	if m.create_time != nil {
		fields = append(fields, contest.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldTitle:
		return m.Title()
	case contest.FieldDescription:
		return m.Description()
	case contest.FieldState:
		return m.State()
	case contest.FieldType:
		return m.GetType()
	case contest.FieldStartTime:
		return m.StartTime()
	case contest.FieldEndTime:
		return m.EndTime()
	case contest.FieldLanguage:
		return m.Language()
	case contest.FieldExtraTime:
		return m.ExtraTime()
	case contest.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contest.FieldTitle:
		return m.OldTitle(ctx)
	case contest.FieldDescription:
		return m.OldDescription(ctx)
	case contest.FieldState:
		return m.OldState(ctx)
	case contest.FieldType:
		return m.OldType(ctx)
	case contest.FieldStartTime:
		return m.OldStartTime(ctx)
	case contest.FieldEndTime:
		return m.OldEndTime(ctx)
	case contest.FieldLanguage:
		return m.OldLanguage(ctx)
	case contest.FieldExtraTime:
		return m.OldExtraTime(ctx)
	case contest.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Contest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contest.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case contest.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case contest.FieldState:
		v, ok := value.(contest.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case contest.FieldType:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case contest.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case contest.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case contest.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case contest.FieldExtraTime:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraTime(v)
		return nil
	case contest.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, contest.FieldType)
	}
	if m.addextra_time != nil {
		fields = append(fields, contest.FieldExtraTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldType:
		return m.AddedType()
	case contest.FieldExtraTime:
		return m.AddedExtraTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contest.FieldType:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case contest.FieldExtraTime:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtraTime(v)
		return nil
	}
	return fmt.Errorf("unknown Contest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Contest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestMutation) ResetField(name string) error {
	switch name {
	case contest.FieldTitle:
		m.ResetTitle()
		return nil
	case contest.FieldDescription:
		m.ResetDescription()
		return nil
	case contest.FieldState:
		m.ResetState()
		return nil
	case contest.FieldType:
		m.ResetType()
		return nil
	case contest.FieldStartTime:
		m.ResetStartTime()
		return nil
	case contest.FieldEndTime:
		m.ResetEndTime()
		return nil
	case contest.FieldLanguage:
		m.ResetLanguage()
		return nil
	case contest.FieldExtraTime:
		m.ResetExtraTime()
		return nil
	case contest.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.problems != nil {
		edges = append(edges, contest.EdgeProblems)
	}
	if m.contestants != nil {
		edges = append(edges, contest.EdgeContestants)
	}
	if m.managers != nil {
		edges = append(edges, contest.EdgeManagers)
	}
	if m.contest_results != nil {
		edges = append(edges, contest.EdgeContestResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.problems))
		for id := range m.problems {
			ids = append(ids, id)
		}
		return ids
	case contest.EdgeContestants:
		ids := make([]ent.Value, 0, len(m.contestants))
		for id := range m.contestants {
			ids = append(ids, id)
		}
		return ids
	case contest.EdgeManagers:
		ids := make([]ent.Value, 0, len(m.managers))
		for id := range m.managers {
			ids = append(ids, id)
		}
		return ids
	case contest.EdgeContestResults:
		ids := make([]ent.Value, 0, len(m.contest_results))
		for id := range m.contest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproblems != nil {
		edges = append(edges, contest.EdgeProblems)
	}
	if m.removedcontestants != nil {
		edges = append(edges, contest.EdgeContestants)
	}
	if m.removedmanagers != nil {
		edges = append(edges, contest.EdgeManagers)
	}
	if m.removedcontest_results != nil {
		edges = append(edges, contest.EdgeContestResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.removedproblems))
		for id := range m.removedproblems {
			ids = append(ids, id)
		}
		return ids
	case contest.EdgeContestants:
		ids := make([]ent.Value, 0, len(m.removedcontestants))
		for id := range m.removedcontestants {
			ids = append(ids, id)
		}
		return ids
	case contest.EdgeManagers:
		ids := make([]ent.Value, 0, len(m.removedmanagers))
		for id := range m.removedmanagers {
			ids = append(ids, id)
		}
		return ids
	case contest.EdgeContestResults:
		ids := make([]ent.Value, 0, len(m.removedcontest_results))
		for id := range m.removedcontest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproblems {
		edges = append(edges, contest.EdgeProblems)
	}
	if m.clearedcontestants {
		edges = append(edges, contest.EdgeContestants)
	}
	if m.clearedmanagers {
		edges = append(edges, contest.EdgeManagers)
	}
	if m.clearedcontest_results {
		edges = append(edges, contest.EdgeContestResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestMutation) EdgeCleared(name string) bool {
	switch name {
	case contest.EdgeProblems:
		return m.clearedproblems
	case contest.EdgeContestants:
		return m.clearedcontestants
	case contest.EdgeManagers:
		return m.clearedmanagers
	case contest.EdgeContestResults:
		return m.clearedcontest_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Contest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestMutation) ResetEdge(name string) error {
	switch name {
	case contest.EdgeProblems:
		m.ResetProblems()
		return nil
	case contest.EdgeContestants:
		m.ResetContestants()
		return nil
	case contest.EdgeManagers:
		m.ResetManagers()
		return nil
	case contest.EdgeContestResults:
		m.ResetContestResults()
		return nil
	}
	return fmt.Errorf("unknown Contest edge %s", name)
}

// ContestResultMutation represents an operation that mutates the ContestResult nodes in the graph.
type ContestResultMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	score              *int32
	addscore           *int32
	rank               *int32
	addrank            *int32
	score_time         *int32
	addscore_time      *int32
	penalty            *int32
	addpenalty         *int32
	clearedFields      map[string]struct{}
	contest            *int64
	clearedcontest     bool
	user               *int64
	cleareduser        bool
	submissions        map[int64]struct{}
	removedsubmissions map[int64]struct{}
	clearedsubmissions bool
	done               bool
	oldValue           func(context.Context) (*ContestResult, error)
	predicates         []predicate.ContestResult
}

var _ ent.Mutation = (*ContestResultMutation)(nil)

// contestresultOption allows management of the mutation configuration using functional options.
type contestresultOption func(*ContestResultMutation)

// newContestResultMutation creates new mutation for the ContestResult entity.
func newContestResultMutation(c config, op Op, opts ...contestresultOption) *ContestResultMutation {
	m := &ContestResultMutation{
		config:        c,
		op:            op,
		typ:           TypeContestResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestResultID sets the ID field of the mutation.
func withContestResultID(id int) contestresultOption {
	return func(m *ContestResultMutation) {
		var (
			err   error
			once  sync.Once
			value *ContestResult
		)
		m.oldValue = func(ctx context.Context) (*ContestResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContestResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContestResult sets the old ContestResult of the mutation.
func withContestResult(node *ContestResult) contestresultOption {
	return func(m *ContestResultMutation) {
		m.oldValue = func(context.Context) (*ContestResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContestResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ContestResultMutation) SetScore(i int32) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ContestResultMutation) Score() (r int32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ContestResult entity.
// If the ContestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestResultMutation) OldScore(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *ContestResultMutation) AddScore(i int32) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ContestResultMutation) AddedScore() (r int32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *ContestResultMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetRank sets the "rank" field.
func (m *ContestResultMutation) SetRank(i int32) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *ContestResultMutation) Rank() (r int32, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the ContestResult entity.
// If the ContestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestResultMutation) OldRank(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *ContestResultMutation) AddRank(i int32) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *ContestResultMutation) AddedRank() (r int32, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *ContestResultMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetScoreTime sets the "score_time" field.
func (m *ContestResultMutation) SetScoreTime(i int32) {
	m.score_time = &i
	m.addscore_time = nil
}

// ScoreTime returns the value of the "score_time" field in the mutation.
func (m *ContestResultMutation) ScoreTime() (r int32, exists bool) {
	v := m.score_time
	if v == nil {
		return
	}
	return *v, true
}

// OldScoreTime returns the old "score_time" field's value of the ContestResult entity.
// If the ContestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestResultMutation) OldScoreTime(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoreTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoreTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoreTime: %w", err)
	}
	return oldValue.ScoreTime, nil
}

// AddScoreTime adds i to the "score_time" field.
func (m *ContestResultMutation) AddScoreTime(i int32) {
	if m.addscore_time != nil {
		*m.addscore_time += i
	} else {
		m.addscore_time = &i
	}
}

// AddedScoreTime returns the value that was added to the "score_time" field in this mutation.
func (m *ContestResultMutation) AddedScoreTime() (r int32, exists bool) {
	v := m.addscore_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetScoreTime resets all changes to the "score_time" field.
func (m *ContestResultMutation) ResetScoreTime() {
	m.score_time = nil
	m.addscore_time = nil
}

// SetPenalty sets the "penalty" field.
func (m *ContestResultMutation) SetPenalty(i int32) {
	m.penalty = &i
	m.addpenalty = nil
}

// Penalty returns the value of the "penalty" field in the mutation.
func (m *ContestResultMutation) Penalty() (r int32, exists bool) {
	v := m.penalty
	if v == nil {
		return
	}
	return *v, true
}

// OldPenalty returns the old "penalty" field's value of the ContestResult entity.
// If the ContestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestResultMutation) OldPenalty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPenalty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPenalty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPenalty: %w", err)
	}
	return oldValue.Penalty, nil
}

// AddPenalty adds i to the "penalty" field.
func (m *ContestResultMutation) AddPenalty(i int32) {
	if m.addpenalty != nil {
		*m.addpenalty += i
	} else {
		m.addpenalty = &i
	}
}

// AddedPenalty returns the value that was added to the "penalty" field in this mutation.
func (m *ContestResultMutation) AddedPenalty() (r int32, exists bool) {
	v := m.addpenalty
	if v == nil {
		return
	}
	return *v, true
}

// ResetPenalty resets all changes to the "penalty" field.
func (m *ContestResultMutation) ResetPenalty() {
	m.penalty = nil
	m.addpenalty = nil
}

// SetContestID sets the "contest_id" field.
func (m *ContestResultMutation) SetContestID(i int64) {
	m.contest = &i
}

// ContestID returns the value of the "contest_id" field in the mutation.
func (m *ContestResultMutation) ContestID() (r int64, exists bool) {
	v := m.contest
	if v == nil {
		return
	}
	return *v, true
}

// OldContestID returns the old "contest_id" field's value of the ContestResult entity.
// If the ContestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestResultMutation) OldContestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestID: %w", err)
	}
	return oldValue.ContestID, nil
}

// ResetContestID resets all changes to the "contest_id" field.
func (m *ContestResultMutation) ResetContestID() {
	m.contest = nil
}

// SetUserID sets the "user_id" field.
func (m *ContestResultMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ContestResultMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ContestResult entity.
// If the ContestResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestResultMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ContestResultMutation) ResetUserID() {
	m.user = nil
}

// ClearContest clears the "contest" edge to the Contest entity.
func (m *ContestResultMutation) ClearContest() {
	m.clearedcontest = true
	m.clearedFields[contestresult.FieldContestID] = struct{}{}
}

// ContestCleared reports if the "contest" edge to the Contest entity was cleared.
func (m *ContestResultMutation) ContestCleared() bool {
	return m.clearedcontest
}

// ContestIDs returns the "contest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContestID instead. It exists only for internal usage by the builders.
func (m *ContestResultMutation) ContestIDs() (ids []int64) {
	if id := m.contest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContest resets all changes to the "contest" edge.
func (m *ContestResultMutation) ResetContest() {
	m.contest = nil
	m.clearedcontest = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ContestResultMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[contestresult.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ContestResultMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ContestResultMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ContestResultMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddSubmissionIDs adds the "submissions" edge to the Submission entity by ids.
func (m *ContestResultMutation) AddSubmissionIDs(ids ...int64) {
	if m.submissions == nil {
		m.submissions = make(map[int64]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the Submission entity.
func (m *ContestResultMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the Submission entity was cleared.
func (m *ContestResultMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the Submission entity by IDs.
func (m *ContestResultMutation) RemoveSubmissionIDs(ids ...int64) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the Submission entity.
func (m *ContestResultMutation) RemovedSubmissionsIDs() (ids []int64) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *ContestResultMutation) SubmissionsIDs() (ids []int64) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *ContestResultMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// Where appends a list predicates to the ContestResultMutation builder.
func (m *ContestResultMutation) Where(ps ...predicate.ContestResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContestResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContestResult).
func (m *ContestResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestResultMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.score != nil {
		fields = append(fields, contestresult.FieldScore)
	}
	if m.rank != nil {
		fields = append(fields, contestresult.FieldRank)
	}
	if m.score_time != nil {
		fields = append(fields, contestresult.FieldScoreTime)
	}
	if m.penalty != nil {
		fields = append(fields, contestresult.FieldPenalty)
	}
	if m.contest != nil {
		fields = append(fields, contestresult.FieldContestID)
	}
	if m.user != nil {
		fields = append(fields, contestresult.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contestresult.FieldScore:
		return m.Score()
	case contestresult.FieldRank:
		return m.Rank()
	case contestresult.FieldScoreTime:
		return m.ScoreTime()
	case contestresult.FieldPenalty:
		return m.Penalty()
	case contestresult.FieldContestID:
		return m.ContestID()
	case contestresult.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contestresult.FieldScore:
		return m.OldScore(ctx)
	case contestresult.FieldRank:
		return m.OldRank(ctx)
	case contestresult.FieldScoreTime:
		return m.OldScoreTime(ctx)
	case contestresult.FieldPenalty:
		return m.OldPenalty(ctx)
	case contestresult.FieldContestID:
		return m.OldContestID(ctx)
	case contestresult.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown ContestResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contestresult.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case contestresult.FieldRank:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case contestresult.FieldScoreTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoreTime(v)
		return nil
	case contestresult.FieldPenalty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPenalty(v)
		return nil
	case contestresult.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestID(v)
		return nil
	case contestresult.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ContestResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestResultMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, contestresult.FieldScore)
	}
	if m.addrank != nil {
		fields = append(fields, contestresult.FieldRank)
	}
	if m.addscore_time != nil {
		fields = append(fields, contestresult.FieldScoreTime)
	}
	if m.addpenalty != nil {
		fields = append(fields, contestresult.FieldPenalty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contestresult.FieldScore:
		return m.AddedScore()
	case contestresult.FieldRank:
		return m.AddedRank()
	case contestresult.FieldScoreTime:
		return m.AddedScoreTime()
	case contestresult.FieldPenalty:
		return m.AddedPenalty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contestresult.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case contestresult.FieldRank:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case contestresult.FieldScoreTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScoreTime(v)
		return nil
	case contestresult.FieldPenalty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPenalty(v)
		return nil
	}
	return fmt.Errorf("unknown ContestResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ContestResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestResultMutation) ResetField(name string) error {
	switch name {
	case contestresult.FieldScore:
		m.ResetScore()
		return nil
	case contestresult.FieldRank:
		m.ResetRank()
		return nil
	case contestresult.FieldScoreTime:
		m.ResetScoreTime()
		return nil
	case contestresult.FieldPenalty:
		m.ResetPenalty()
		return nil
	case contestresult.FieldContestID:
		m.ResetContestID()
		return nil
	case contestresult.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown ContestResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.contest != nil {
		edges = append(edges, contestresult.EdgeContest)
	}
	if m.user != nil {
		edges = append(edges, contestresult.EdgeUser)
	}
	if m.submissions != nil {
		edges = append(edges, contestresult.EdgeSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contestresult.EdgeContest:
		if id := m.contest; id != nil {
			return []ent.Value{*id}
		}
	case contestresult.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case contestresult.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsubmissions != nil {
		edges = append(edges, contestresult.EdgeSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestResultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contestresult.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcontest {
		edges = append(edges, contestresult.EdgeContest)
	}
	if m.cleareduser {
		edges = append(edges, contestresult.EdgeUser)
	}
	if m.clearedsubmissions {
		edges = append(edges, contestresult.EdgeSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestResultMutation) EdgeCleared(name string) bool {
	switch name {
	case contestresult.EdgeContest:
		return m.clearedcontest
	case contestresult.EdgeUser:
		return m.cleareduser
	case contestresult.EdgeSubmissions:
		return m.clearedsubmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestResultMutation) ClearEdge(name string) error {
	switch name {
	case contestresult.EdgeContest:
		m.ClearContest()
		return nil
	case contestresult.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ContestResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestResultMutation) ResetEdge(name string) error {
	switch name {
	case contestresult.EdgeContest:
		m.ResetContest()
		return nil
	case contestresult.EdgeUser:
		m.ResetUser()
		return nil
	case contestresult.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	}
	return fmt.Errorf("unknown ContestResult edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	group_name      *string
	is_root         *bool
	clearedFields   map[string]struct{}
	manage          map[int64]struct{}
	removedmanage   map[int64]struct{}
	clearedmanage   bool
	contests        map[int64]struct{}
	removedcontests map[int64]struct{}
	clearedcontests bool
	problems        map[int64]struct{}
	removedproblems map[int64]struct{}
	clearedproblems bool
	users           map[int64]struct{}
	removedusers    map[int64]struct{}
	clearedusers    bool
	done            bool
	oldValue        func(context.Context) (*Group, error)
	predicates      []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int64) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupName sets the "group_name" field.
func (m *GroupMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *GroupMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *GroupMutation) ResetGroupName() {
	m.group_name = nil
}

// SetIsRoot sets the "is_root" field.
func (m *GroupMutation) SetIsRoot(b bool) {
	m.is_root = &b
}

// IsRoot returns the value of the "is_root" field in the mutation.
func (m *GroupMutation) IsRoot() (r bool, exists bool) {
	v := m.is_root
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRoot returns the old "is_root" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldIsRoot(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRoot: %w", err)
	}
	return oldValue.IsRoot, nil
}

// ResetIsRoot resets all changes to the "is_root" field.
func (m *GroupMutation) ResetIsRoot() {
	m.is_root = nil
}

// AddManageIDs adds the "manage" edge to the Contest entity by ids.
func (m *GroupMutation) AddManageIDs(ids ...int64) {
	if m.manage == nil {
		m.manage = make(map[int64]struct{})
	}
	for i := range ids {
		m.manage[ids[i]] = struct{}{}
	}
}

// ClearManage clears the "manage" edge to the Contest entity.
func (m *GroupMutation) ClearManage() {
	m.clearedmanage = true
}

// ManageCleared reports if the "manage" edge to the Contest entity was cleared.
func (m *GroupMutation) ManageCleared() bool {
	return m.clearedmanage
}

// RemoveManageIDs removes the "manage" edge to the Contest entity by IDs.
func (m *GroupMutation) RemoveManageIDs(ids ...int64) {
	if m.removedmanage == nil {
		m.removedmanage = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.manage, ids[i])
		m.removedmanage[ids[i]] = struct{}{}
	}
}

// RemovedManage returns the removed IDs of the "manage" edge to the Contest entity.
func (m *GroupMutation) RemovedManageIDs() (ids []int64) {
	for id := range m.removedmanage {
		ids = append(ids, id)
	}
	return
}

// ManageIDs returns the "manage" edge IDs in the mutation.
func (m *GroupMutation) ManageIDs() (ids []int64) {
	for id := range m.manage {
		ids = append(ids, id)
	}
	return
}

// ResetManage resets all changes to the "manage" edge.
func (m *GroupMutation) ResetManage() {
	m.manage = nil
	m.clearedmanage = false
	m.removedmanage = nil
}

// AddContestIDs adds the "contests" edge to the Contest entity by ids.
func (m *GroupMutation) AddContestIDs(ids ...int64) {
	if m.contests == nil {
		m.contests = make(map[int64]struct{})
	}
	for i := range ids {
		m.contests[ids[i]] = struct{}{}
	}
}

// ClearContests clears the "contests" edge to the Contest entity.
func (m *GroupMutation) ClearContests() {
	m.clearedcontests = true
}

// ContestsCleared reports if the "contests" edge to the Contest entity was cleared.
func (m *GroupMutation) ContestsCleared() bool {
	return m.clearedcontests
}

// RemoveContestIDs removes the "contests" edge to the Contest entity by IDs.
func (m *GroupMutation) RemoveContestIDs(ids ...int64) {
	if m.removedcontests == nil {
		m.removedcontests = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.contests, ids[i])
		m.removedcontests[ids[i]] = struct{}{}
	}
}

// RemovedContests returns the removed IDs of the "contests" edge to the Contest entity.
func (m *GroupMutation) RemovedContestsIDs() (ids []int64) {
	for id := range m.removedcontests {
		ids = append(ids, id)
	}
	return
}

// ContestsIDs returns the "contests" edge IDs in the mutation.
func (m *GroupMutation) ContestsIDs() (ids []int64) {
	for id := range m.contests {
		ids = append(ids, id)
	}
	return
}

// ResetContests resets all changes to the "contests" edge.
func (m *GroupMutation) ResetContests() {
	m.contests = nil
	m.clearedcontests = false
	m.removedcontests = nil
}

// AddProblemIDs adds the "problems" edge to the Problem entity by ids.
func (m *GroupMutation) AddProblemIDs(ids ...int64) {
	if m.problems == nil {
		m.problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.problems[ids[i]] = struct{}{}
	}
}

// ClearProblems clears the "problems" edge to the Problem entity.
func (m *GroupMutation) ClearProblems() {
	m.clearedproblems = true
}

// ProblemsCleared reports if the "problems" edge to the Problem entity was cleared.
func (m *GroupMutation) ProblemsCleared() bool {
	return m.clearedproblems
}

// RemoveProblemIDs removes the "problems" edge to the Problem entity by IDs.
func (m *GroupMutation) RemoveProblemIDs(ids ...int64) {
	if m.removedproblems == nil {
		m.removedproblems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.problems, ids[i])
		m.removedproblems[ids[i]] = struct{}{}
	}
}

// RemovedProblems returns the removed IDs of the "problems" edge to the Problem entity.
func (m *GroupMutation) RemovedProblemsIDs() (ids []int64) {
	for id := range m.removedproblems {
		ids = append(ids, id)
	}
	return
}

// ProblemsIDs returns the "problems" edge IDs in the mutation.
func (m *GroupMutation) ProblemsIDs() (ids []int64) {
	for id := range m.problems {
		ids = append(ids, id)
	}
	return
}

// ResetProblems resets all changes to the "problems" edge.
func (m *GroupMutation) ResetProblems() {
	m.problems = nil
	m.clearedproblems = false
	m.removedproblems = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.group_name != nil {
		fields = append(fields, group.FieldGroupName)
	}
	if m.is_root != nil {
		fields = append(fields, group.FieldIsRoot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldGroupName:
		return m.GroupName()
	case group.FieldIsRoot:
		return m.IsRoot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldGroupName:
		return m.OldGroupName(ctx)
	case group.FieldIsRoot:
		return m.OldIsRoot(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case group.FieldIsRoot:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRoot(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldGroupName:
		m.ResetGroupName()
		return nil
	case group.FieldIsRoot:
		m.ResetIsRoot()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.manage != nil {
		edges = append(edges, group.EdgeManage)
	}
	if m.contests != nil {
		edges = append(edges, group.EdgeContests)
	}
	if m.problems != nil {
		edges = append(edges, group.EdgeProblems)
	}
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeManage:
		ids := make([]ent.Value, 0, len(m.manage))
		for id := range m.manage {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeContests:
		ids := make([]ent.Value, 0, len(m.contests))
		for id := range m.contests {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.problems))
		for id := range m.problems {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmanage != nil {
		edges = append(edges, group.EdgeManage)
	}
	if m.removedcontests != nil {
		edges = append(edges, group.EdgeContests)
	}
	if m.removedproblems != nil {
		edges = append(edges, group.EdgeProblems)
	}
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeManage:
		ids := make([]ent.Value, 0, len(m.removedmanage))
		for id := range m.removedmanage {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeContests:
		ids := make([]ent.Value, 0, len(m.removedcontests))
		for id := range m.removedcontests {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.removedproblems))
		for id := range m.removedproblems {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmanage {
		edges = append(edges, group.EdgeManage)
	}
	if m.clearedcontests {
		edges = append(edges, group.EdgeContests)
	}
	if m.clearedproblems {
		edges = append(edges, group.EdgeProblems)
	}
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeManage:
		return m.clearedmanage
	case group.EdgeContests:
		return m.clearedcontests
	case group.EdgeProblems:
		return m.clearedproblems
	case group.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeManage:
		m.ResetManage()
		return nil
	case group.EdgeContests:
		m.ResetContests()
		return nil
	case group.EdgeProblems:
		m.ResetProblems()
		return nil
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// LoginSessionMutation represents an operation that mutates the LoginSession nodes in the graph.
type LoginSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	clearedFields map[string]struct{}
	users         *int64
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*LoginSession, error)
	predicates    []predicate.LoginSession
}

var _ ent.Mutation = (*LoginSessionMutation)(nil)

// loginsessionOption allows management of the mutation configuration using functional options.
type loginsessionOption func(*LoginSessionMutation)

// newLoginSessionMutation creates new mutation for the LoginSession entity.
func newLoginSessionMutation(c config, op Op, opts ...loginsessionOption) *LoginSessionMutation {
	m := &LoginSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginSessionID sets the ID field of the mutation.
func withLoginSessionID(id int64) loginsessionOption {
	return func(m *LoginSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginSession
		)
		m.oldValue = func(ctx context.Context) (*LoginSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginSession sets the old LoginSession of the mutation.
func withLoginSession(node *LoginSession) loginsessionOption {
	return func(m *LoginSessionMutation) {
		m.oldValue = func(context.Context) (*LoginSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginSession entities.
func (m *LoginSessionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginSessionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginSessionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *LoginSessionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LoginSessionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the LoginSession entity.
// If the LoginSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginSessionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LoginSessionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUserID sets the "user_id" field.
func (m *LoginSessionMutation) SetUserID(i int64) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginSessionMutation) UserID() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginSession entity.
// If the LoginSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginSessionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginSessionMutation) ResetUserID() {
	m.users = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *LoginSessionMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *LoginSessionMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[loginsession.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *LoginSessionMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *LoginSessionMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *LoginSessionMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *LoginSessionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the LoginSessionMutation builder.
func (m *LoginSessionMutation) Where(ps ...predicate.LoginSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginSession).
func (m *LoginSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginSessionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, loginsession.FieldCreateTime)
	}
	if m.users != nil {
		fields = append(fields, loginsession.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginsession.FieldCreateTime:
		return m.CreateTime()
	case loginsession.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginsession.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case loginsession.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown LoginSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginsession.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case loginsession.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown LoginSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginSessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LoginSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LoginSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginSessionMutation) ResetField(name string) error {
	switch name {
	case loginsession.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case loginsession.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown LoginSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, loginsession.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loginsession.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, loginsession.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case loginsession.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginSessionMutation) ClearEdge(name string) error {
	switch name {
	case loginsession.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown LoginSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginSessionMutation) ResetEdge(name string) error {
	switch name {
	case loginsession.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown LoginSession edge %s", name)
}

// ProblemMutation represents an operation that mutates the Problem nodes in the graph.
type ProblemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	title               *string
	content             *string
	score               *int16
	addscore            *int16
	case_version        *int16
	addcase_version     *int16
	index               *int16
	addindex            *int16
	lf_compare          *schema.LfCompare
	is_deleted          *bool
	visibility          *problem.Visibility
	metadata            *map[string]string
	clearedFields       map[string]struct{}
	submission          map[int64]struct{}
	removedsubmission   map[int64]struct{}
	clearedsubmission   bool
	contest             *int64
	clearedcontest      bool
	owner               *int64
	clearedowner        bool
	problem_type        *int64
	clearedproblem_type bool
	judgers             map[int64]struct{}
	removedjudgers      map[int64]struct{}
	clearedjudgers      bool
	done                bool
	oldValue            func(context.Context) (*Problem, error)
	predicates          []predicate.Problem
}

var _ ent.Mutation = (*ProblemMutation)(nil)

// problemOption allows management of the mutation configuration using functional options.
type problemOption func(*ProblemMutation)

// newProblemMutation creates new mutation for the Problem entity.
func newProblemMutation(c config, op Op, opts ...problemOption) *ProblemMutation {
	m := &ProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProblemID sets the ID field of the mutation.
func withProblemID(id int64) problemOption {
	return func(m *ProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *Problem
		)
		m.oldValue = func(ctx context.Context) (*Problem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Problem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProblem sets the old Problem of the mutation.
func withProblem(node *Problem) problemOption {
	return func(m *ProblemMutation) {
		m.oldValue = func(context.Context) (*Problem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Problem entities.
func (m *ProblemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProblemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProblemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Problem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProblemTypeID sets the "problem_type_id" field.
func (m *ProblemMutation) SetProblemTypeID(i int64) {
	m.problem_type = &i
}

// ProblemTypeID returns the value of the "problem_type_id" field in the mutation.
func (m *ProblemMutation) ProblemTypeID() (r int64, exists bool) {
	v := m.problem_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProblemTypeID returns the old "problem_type_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldProblemTypeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProblemTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProblemTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProblemTypeID: %w", err)
	}
	return oldValue.ProblemTypeID, nil
}

// ResetProblemTypeID resets all changes to the "problem_type_id" field.
func (m *ProblemMutation) ResetProblemTypeID() {
	m.problem_type = nil
}

// SetTitle sets the "title" field.
func (m *ProblemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProblemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProblemMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *ProblemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ProblemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ProblemMutation) ResetContent() {
	m.content = nil
}

// SetScore sets the "score" field.
func (m *ProblemMutation) SetScore(i int16) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ProblemMutation) Score() (r int16, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldScore(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *ProblemMutation) AddScore(i int16) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ProblemMutation) AddedScore() (r int16, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *ProblemMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetCaseVersion sets the "case_version" field.
func (m *ProblemMutation) SetCaseVersion(i int16) {
	m.case_version = &i
	m.addcase_version = nil
}

// CaseVersion returns the value of the "case_version" field in the mutation.
func (m *ProblemMutation) CaseVersion() (r int16, exists bool) {
	v := m.case_version
	if v == nil {
		return
	}
	return *v, true
}

// OldCaseVersion returns the old "case_version" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCaseVersion(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaseVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaseVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaseVersion: %w", err)
	}
	return oldValue.CaseVersion, nil
}

// AddCaseVersion adds i to the "case_version" field.
func (m *ProblemMutation) AddCaseVersion(i int16) {
	if m.addcase_version != nil {
		*m.addcase_version += i
	} else {
		m.addcase_version = &i
	}
}

// AddedCaseVersion returns the value that was added to the "case_version" field in this mutation.
func (m *ProblemMutation) AddedCaseVersion() (r int16, exists bool) {
	v := m.addcase_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaseVersion resets all changes to the "case_version" field.
func (m *ProblemMutation) ResetCaseVersion() {
	m.case_version = nil
	m.addcase_version = nil
}

// SetIndex sets the "index" field.
func (m *ProblemMutation) SetIndex(i int16) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *ProblemMutation) Index() (r int16, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldIndex(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *ProblemMutation) AddIndex(i int16) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *ProblemMutation) AddedIndex() (r int16, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *ProblemMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetLfCompare sets the "lf_compare" field.
func (m *ProblemMutation) SetLfCompare(sc schema.LfCompare) {
	m.lf_compare = &sc
}

// LfCompare returns the value of the "lf_compare" field in the mutation.
func (m *ProblemMutation) LfCompare() (r schema.LfCompare, exists bool) {
	v := m.lf_compare
	if v == nil {
		return
	}
	return *v, true
}

// OldLfCompare returns the old "lf_compare" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldLfCompare(ctx context.Context) (v schema.LfCompare, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLfCompare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLfCompare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLfCompare: %w", err)
	}
	return oldValue.LfCompare, nil
}

// ResetLfCompare resets all changes to the "lf_compare" field.
func (m *ProblemMutation) ResetLfCompare() {
	m.lf_compare = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *ProblemMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *ProblemMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *ProblemMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetContestID sets the "contest_id" field.
func (m *ProblemMutation) SetContestID(i int64) {
	m.contest = &i
}

// ContestID returns the value of the "contest_id" field in the mutation.
func (m *ProblemMutation) ContestID() (r int64, exists bool) {
	v := m.contest
	if v == nil {
		return
	}
	return *v, true
}

// OldContestID returns the old "contest_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldContestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestID: %w", err)
	}
	return oldValue.ContestID, nil
}

// ResetContestID resets all changes to the "contest_id" field.
func (m *ProblemMutation) ResetContestID() {
	m.contest = nil
}

// SetUserID sets the "user_id" field.
func (m *ProblemMutation) SetUserID(i int64) {
	m.owner = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProblemMutation) UserID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProblemMutation) ResetUserID() {
	m.owner = nil
}

// SetVisibility sets the "visibility" field.
func (m *ProblemMutation) SetVisibility(pr problem.Visibility) {
	m.visibility = &pr
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *ProblemMutation) Visibility() (r problem.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldVisibility(ctx context.Context) (v problem.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *ProblemMutation) ResetVisibility() {
	m.visibility = nil
}

// SetMetadata sets the "metadata" field.
func (m *ProblemMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ProblemMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ProblemMutation) ResetMetadata() {
	m.metadata = nil
}

// AddSubmissionIDs adds the "submission" edge to the Submission entity by ids.
func (m *ProblemMutation) AddSubmissionIDs(ids ...int64) {
	if m.submission == nil {
		m.submission = make(map[int64]struct{})
	}
	for i := range ids {
		m.submission[ids[i]] = struct{}{}
	}
}

// ClearSubmission clears the "submission" edge to the Submission entity.
func (m *ProblemMutation) ClearSubmission() {
	m.clearedsubmission = true
}

// SubmissionCleared reports if the "submission" edge to the Submission entity was cleared.
func (m *ProblemMutation) SubmissionCleared() bool {
	return m.clearedsubmission
}

// RemoveSubmissionIDs removes the "submission" edge to the Submission entity by IDs.
func (m *ProblemMutation) RemoveSubmissionIDs(ids ...int64) {
	if m.removedsubmission == nil {
		m.removedsubmission = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.submission, ids[i])
		m.removedsubmission[ids[i]] = struct{}{}
	}
}

// RemovedSubmission returns the removed IDs of the "submission" edge to the Submission entity.
func (m *ProblemMutation) RemovedSubmissionIDs() (ids []int64) {
	for id := range m.removedsubmission {
		ids = append(ids, id)
	}
	return
}

// SubmissionIDs returns the "submission" edge IDs in the mutation.
func (m *ProblemMutation) SubmissionIDs() (ids []int64) {
	for id := range m.submission {
		ids = append(ids, id)
	}
	return
}

// ResetSubmission resets all changes to the "submission" edge.
func (m *ProblemMutation) ResetSubmission() {
	m.submission = nil
	m.clearedsubmission = false
	m.removedsubmission = nil
}

// ClearContest clears the "contest" edge to the Contest entity.
func (m *ProblemMutation) ClearContest() {
	m.clearedcontest = true
	m.clearedFields[problem.FieldContestID] = struct{}{}
}

// ContestCleared reports if the "contest" edge to the Contest entity was cleared.
func (m *ProblemMutation) ContestCleared() bool {
	return m.clearedcontest
}

// ContestIDs returns the "contest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContestID instead. It exists only for internal usage by the builders.
func (m *ProblemMutation) ContestIDs() (ids []int64) {
	if id := m.contest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContest resets all changes to the "contest" edge.
func (m *ProblemMutation) ResetContest() {
	m.contest = nil
	m.clearedcontest = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ProblemMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ProblemMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[problem.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ProblemMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ProblemMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ProblemMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ProblemMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearProblemType clears the "problem_type" edge to the ProblemType entity.
func (m *ProblemMutation) ClearProblemType() {
	m.clearedproblem_type = true
	m.clearedFields[problem.FieldProblemTypeID] = struct{}{}
}

// ProblemTypeCleared reports if the "problem_type" edge to the ProblemType entity was cleared.
func (m *ProblemMutation) ProblemTypeCleared() bool {
	return m.clearedproblem_type
}

// ProblemTypeIDs returns the "problem_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProblemTypeID instead. It exists only for internal usage by the builders.
func (m *ProblemMutation) ProblemTypeIDs() (ids []int64) {
	if id := m.problem_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProblemType resets all changes to the "problem_type" edge.
func (m *ProblemMutation) ResetProblemType() {
	m.problem_type = nil
	m.clearedproblem_type = false
}

// AddJudgerIDs adds the "judgers" edge to the Group entity by ids.
func (m *ProblemMutation) AddJudgerIDs(ids ...int64) {
	if m.judgers == nil {
		m.judgers = make(map[int64]struct{})
	}
	for i := range ids {
		m.judgers[ids[i]] = struct{}{}
	}
}

// ClearJudgers clears the "judgers" edge to the Group entity.
func (m *ProblemMutation) ClearJudgers() {
	m.clearedjudgers = true
}

// JudgersCleared reports if the "judgers" edge to the Group entity was cleared.
func (m *ProblemMutation) JudgersCleared() bool {
	return m.clearedjudgers
}

// RemoveJudgerIDs removes the "judgers" edge to the Group entity by IDs.
func (m *ProblemMutation) RemoveJudgerIDs(ids ...int64) {
	if m.removedjudgers == nil {
		m.removedjudgers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.judgers, ids[i])
		m.removedjudgers[ids[i]] = struct{}{}
	}
}

// RemovedJudgers returns the removed IDs of the "judgers" edge to the Group entity.
func (m *ProblemMutation) RemovedJudgersIDs() (ids []int64) {
	for id := range m.removedjudgers {
		ids = append(ids, id)
	}
	return
}

// JudgersIDs returns the "judgers" edge IDs in the mutation.
func (m *ProblemMutation) JudgersIDs() (ids []int64) {
	for id := range m.judgers {
		ids = append(ids, id)
	}
	return
}

// ResetJudgers resets all changes to the "judgers" edge.
func (m *ProblemMutation) ResetJudgers() {
	m.judgers = nil
	m.clearedjudgers = false
	m.removedjudgers = nil
}

// Where appends a list predicates to the ProblemMutation builder.
func (m *ProblemMutation) Where(ps ...predicate.Problem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProblemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProblemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Problem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProblemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProblemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Problem).
func (m *ProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProblemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.problem_type != nil {
		fields = append(fields, problem.FieldProblemTypeID)
	}
	if m.title != nil {
		fields = append(fields, problem.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, problem.FieldContent)
	}
	if m.score != nil {
		fields = append(fields, problem.FieldScore)
	}
	if m.case_version != nil {
		fields = append(fields, problem.FieldCaseVersion)
	}
	if m.index != nil {
		fields = append(fields, problem.FieldIndex)
	}
	if m.lf_compare != nil {
		fields = append(fields, problem.FieldLfCompare)
	}
	if m.is_deleted != nil {
		fields = append(fields, problem.FieldIsDeleted)
	}
	if m.contest != nil {
		fields = append(fields, problem.FieldContestID)
	}
	if m.owner != nil {
		fields = append(fields, problem.FieldUserID)
	}
	if m.visibility != nil {
		fields = append(fields, problem.FieldVisibility)
	}
	if m.metadata != nil {
		fields = append(fields, problem.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldProblemTypeID:
		return m.ProblemTypeID()
	case problem.FieldTitle:
		return m.Title()
	case problem.FieldContent:
		return m.Content()
	case problem.FieldScore:
		return m.Score()
	case problem.FieldCaseVersion:
		return m.CaseVersion()
	case problem.FieldIndex:
		return m.Index()
	case problem.FieldLfCompare:
		return m.LfCompare()
	case problem.FieldIsDeleted:
		return m.IsDeleted()
	case problem.FieldContestID:
		return m.ContestID()
	case problem.FieldUserID:
		return m.UserID()
	case problem.FieldVisibility:
		return m.Visibility()
	case problem.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case problem.FieldProblemTypeID:
		return m.OldProblemTypeID(ctx)
	case problem.FieldTitle:
		return m.OldTitle(ctx)
	case problem.FieldContent:
		return m.OldContent(ctx)
	case problem.FieldScore:
		return m.OldScore(ctx)
	case problem.FieldCaseVersion:
		return m.OldCaseVersion(ctx)
	case problem.FieldIndex:
		return m.OldIndex(ctx)
	case problem.FieldLfCompare:
		return m.OldLfCompare(ctx)
	case problem.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case problem.FieldContestID:
		return m.OldContestID(ctx)
	case problem.FieldUserID:
		return m.OldUserID(ctx)
	case problem.FieldVisibility:
		return m.OldVisibility(ctx)
	case problem.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Problem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case problem.FieldProblemTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProblemTypeID(v)
		return nil
	case problem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case problem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case problem.FieldScore:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case problem.FieldCaseVersion:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaseVersion(v)
		return nil
	case problem.FieldIndex:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case problem.FieldLfCompare:
		v, ok := value.(schema.LfCompare)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLfCompare(v)
		return nil
	case problem.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case problem.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestID(v)
		return nil
	case problem.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case problem.FieldVisibility:
		v, ok := value.(problem.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case problem.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProblemMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, problem.FieldScore)
	}
	if m.addcase_version != nil {
		fields = append(fields, problem.FieldCaseVersion)
	}
	if m.addindex != nil {
		fields = append(fields, problem.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProblemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldScore:
		return m.AddedScore()
	case problem.FieldCaseVersion:
		return m.AddedCaseVersion()
	case problem.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case problem.FieldScore:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case problem.FieldCaseVersion:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaseVersion(v)
		return nil
	case problem.FieldIndex:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Problem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProblemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProblemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Problem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProblemMutation) ResetField(name string) error {
	switch name {
	case problem.FieldProblemTypeID:
		m.ResetProblemTypeID()
		return nil
	case problem.FieldTitle:
		m.ResetTitle()
		return nil
	case problem.FieldContent:
		m.ResetContent()
		return nil
	case problem.FieldScore:
		m.ResetScore()
		return nil
	case problem.FieldCaseVersion:
		m.ResetCaseVersion()
		return nil
	case problem.FieldIndex:
		m.ResetIndex()
		return nil
	case problem.FieldLfCompare:
		m.ResetLfCompare()
		return nil
	case problem.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case problem.FieldContestID:
		m.ResetContestID()
		return nil
	case problem.FieldUserID:
		m.ResetUserID()
		return nil
	case problem.FieldVisibility:
		m.ResetVisibility()
		return nil
	case problem.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.submission != nil {
		edges = append(edges, problem.EdgeSubmission)
	}
	if m.contest != nil {
		edges = append(edges, problem.EdgeContest)
	}
	if m.owner != nil {
		edges = append(edges, problem.EdgeOwner)
	}
	if m.problem_type != nil {
		edges = append(edges, problem.EdgeProblemType)
	}
	if m.judgers != nil {
		edges = append(edges, problem.EdgeJudgers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProblemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case problem.EdgeSubmission:
		ids := make([]ent.Value, 0, len(m.submission))
		for id := range m.submission {
			ids = append(ids, id)
		}
		return ids
	case problem.EdgeContest:
		if id := m.contest; id != nil {
			return []ent.Value{*id}
		}
	case problem.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case problem.EdgeProblemType:
		if id := m.problem_type; id != nil {
			return []ent.Value{*id}
		}
	case problem.EdgeJudgers:
		ids := make([]ent.Value, 0, len(m.judgers))
		for id := range m.judgers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedsubmission != nil {
		edges = append(edges, problem.EdgeSubmission)
	}
	if m.removedjudgers != nil {
		edges = append(edges, problem.EdgeJudgers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProblemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case problem.EdgeSubmission:
		ids := make([]ent.Value, 0, len(m.removedsubmission))
		for id := range m.removedsubmission {
			ids = append(ids, id)
		}
		return ids
	case problem.EdgeJudgers:
		ids := make([]ent.Value, 0, len(m.removedjudgers))
		for id := range m.removedjudgers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsubmission {
		edges = append(edges, problem.EdgeSubmission)
	}
	if m.clearedcontest {
		edges = append(edges, problem.EdgeContest)
	}
	if m.clearedowner {
		edges = append(edges, problem.EdgeOwner)
	}
	if m.clearedproblem_type {
		edges = append(edges, problem.EdgeProblemType)
	}
	if m.clearedjudgers {
		edges = append(edges, problem.EdgeJudgers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProblemMutation) EdgeCleared(name string) bool {
	switch name {
	case problem.EdgeSubmission:
		return m.clearedsubmission
	case problem.EdgeContest:
		return m.clearedcontest
	case problem.EdgeOwner:
		return m.clearedowner
	case problem.EdgeProblemType:
		return m.clearedproblem_type
	case problem.EdgeJudgers:
		return m.clearedjudgers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProblemMutation) ClearEdge(name string) error {
	switch name {
	case problem.EdgeContest:
		m.ClearContest()
		return nil
	case problem.EdgeOwner:
		m.ClearOwner()
		return nil
	case problem.EdgeProblemType:
		m.ClearProblemType()
		return nil
	}
	return fmt.Errorf("unknown Problem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProblemMutation) ResetEdge(name string) error {
	switch name {
	case problem.EdgeSubmission:
		m.ResetSubmission()
		return nil
	case problem.EdgeContest:
		m.ResetContest()
		return nil
	case problem.EdgeOwner:
		m.ResetOwner()
		return nil
	case problem.EdgeProblemType:
		m.ResetProblemType()
		return nil
	case problem.EdgeJudgers:
		m.ResetJudgers()
		return nil
	}
	return fmt.Errorf("unknown Problem edge %s", name)
}

// ProblemTypeMutation represents an operation that mutates the ProblemType nodes in the graph.
type ProblemTypeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	slug_name               *string
	display_name            *string
	description             *string
	submission_channel_name *string
	self_test_channel_name  *string
	judge                   *string
	clearedFields           map[string]struct{}
	problems                map[int64]struct{}
	removedproblems         map[int64]struct{}
	clearedproblems         bool
	done                    bool
	oldValue                func(context.Context) (*ProblemType, error)
	predicates              []predicate.ProblemType
}

var _ ent.Mutation = (*ProblemTypeMutation)(nil)

// problemtypeOption allows management of the mutation configuration using functional options.
type problemtypeOption func(*ProblemTypeMutation)

// newProblemTypeMutation creates new mutation for the ProblemType entity.
func newProblemTypeMutation(c config, op Op, opts ...problemtypeOption) *ProblemTypeMutation {
	m := &ProblemTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProblemType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProblemTypeID sets the ID field of the mutation.
func withProblemTypeID(id int64) problemtypeOption {
	return func(m *ProblemTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProblemType
		)
		m.oldValue = func(ctx context.Context) (*ProblemType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProblemType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProblemType sets the old ProblemType of the mutation.
func withProblemType(node *ProblemType) problemtypeOption {
	return func(m *ProblemTypeMutation) {
		m.oldValue = func(context.Context) (*ProblemType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProblemTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProblemTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProblemType entities.
func (m *ProblemTypeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProblemTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProblemTypeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProblemType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlugName sets the "slug_name" field.
func (m *ProblemTypeMutation) SetSlugName(s string) {
	m.slug_name = &s
}

// SlugName returns the value of the "slug_name" field in the mutation.
func (m *ProblemTypeMutation) SlugName() (r string, exists bool) {
	v := m.slug_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSlugName returns the old "slug_name" field's value of the ProblemType entity.
// If the ProblemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemTypeMutation) OldSlugName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlugName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlugName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlugName: %w", err)
	}
	return oldValue.SlugName, nil
}

// ResetSlugName resets all changes to the "slug_name" field.
func (m *ProblemTypeMutation) ResetSlugName() {
	m.slug_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ProblemTypeMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProblemTypeMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProblemType entity.
// If the ProblemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemTypeMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProblemTypeMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetDescription sets the "description" field.
func (m *ProblemTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProblemTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProblemType entity.
// If the ProblemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProblemTypeMutation) ResetDescription() {
	m.description = nil
}

// SetSubmissionChannelName sets the "submission_channel_name" field.
func (m *ProblemTypeMutation) SetSubmissionChannelName(s string) {
	m.submission_channel_name = &s
}

// SubmissionChannelName returns the value of the "submission_channel_name" field in the mutation.
func (m *ProblemTypeMutation) SubmissionChannelName() (r string, exists bool) {
	v := m.submission_channel_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmissionChannelName returns the old "submission_channel_name" field's value of the ProblemType entity.
// If the ProblemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemTypeMutation) OldSubmissionChannelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmissionChannelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmissionChannelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmissionChannelName: %w", err)
	}
	return oldValue.SubmissionChannelName, nil
}

// ResetSubmissionChannelName resets all changes to the "submission_channel_name" field.
func (m *ProblemTypeMutation) ResetSubmissionChannelName() {
	m.submission_channel_name = nil
}

// SetSelfTestChannelName sets the "self_test_channel_name" field.
func (m *ProblemTypeMutation) SetSelfTestChannelName(s string) {
	m.self_test_channel_name = &s
}

// SelfTestChannelName returns the value of the "self_test_channel_name" field in the mutation.
func (m *ProblemTypeMutation) SelfTestChannelName() (r string, exists bool) {
	v := m.self_test_channel_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfTestChannelName returns the old "self_test_channel_name" field's value of the ProblemType entity.
// If the ProblemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemTypeMutation) OldSelfTestChannelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfTestChannelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfTestChannelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfTestChannelName: %w", err)
	}
	return oldValue.SelfTestChannelName, nil
}

// ResetSelfTestChannelName resets all changes to the "self_test_channel_name" field.
func (m *ProblemTypeMutation) ResetSelfTestChannelName() {
	m.self_test_channel_name = nil
}

// SetJudge sets the "judge" field.
func (m *ProblemTypeMutation) SetJudge(s string) {
	m.judge = &s
}

// Judge returns the value of the "judge" field in the mutation.
func (m *ProblemTypeMutation) Judge() (r string, exists bool) {
	v := m.judge
	if v == nil {
		return
	}
	return *v, true
}

// OldJudge returns the old "judge" field's value of the ProblemType entity.
// If the ProblemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemTypeMutation) OldJudge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJudge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJudge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJudge: %w", err)
	}
	return oldValue.Judge, nil
}

// ResetJudge resets all changes to the "judge" field.
func (m *ProblemTypeMutation) ResetJudge() {
	m.judge = nil
}

// AddProblemIDs adds the "problems" edge to the Problem entity by ids.
func (m *ProblemTypeMutation) AddProblemIDs(ids ...int64) {
	if m.problems == nil {
		m.problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.problems[ids[i]] = struct{}{}
	}
}

// ClearProblems clears the "problems" edge to the Problem entity.
func (m *ProblemTypeMutation) ClearProblems() {
	m.clearedproblems = true
}

// ProblemsCleared reports if the "problems" edge to the Problem entity was cleared.
func (m *ProblemTypeMutation) ProblemsCleared() bool {
	return m.clearedproblems
}

// RemoveProblemIDs removes the "problems" edge to the Problem entity by IDs.
func (m *ProblemTypeMutation) RemoveProblemIDs(ids ...int64) {
	if m.removedproblems == nil {
		m.removedproblems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.problems, ids[i])
		m.removedproblems[ids[i]] = struct{}{}
	}
}

// RemovedProblems returns the removed IDs of the "problems" edge to the Problem entity.
func (m *ProblemTypeMutation) RemovedProblemsIDs() (ids []int64) {
	for id := range m.removedproblems {
		ids = append(ids, id)
	}
	return
}

// ProblemsIDs returns the "problems" edge IDs in the mutation.
func (m *ProblemTypeMutation) ProblemsIDs() (ids []int64) {
	for id := range m.problems {
		ids = append(ids, id)
	}
	return
}

// ResetProblems resets all changes to the "problems" edge.
func (m *ProblemTypeMutation) ResetProblems() {
	m.problems = nil
	m.clearedproblems = false
	m.removedproblems = nil
}

// Where appends a list predicates to the ProblemTypeMutation builder.
func (m *ProblemTypeMutation) Where(ps ...predicate.ProblemType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProblemTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProblemTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProblemType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProblemTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProblemTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProblemType).
func (m *ProblemTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProblemTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.slug_name != nil {
		fields = append(fields, problemtype.FieldSlugName)
	}
	if m.display_name != nil {
		fields = append(fields, problemtype.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, problemtype.FieldDescription)
	}
	if m.submission_channel_name != nil {
		fields = append(fields, problemtype.FieldSubmissionChannelName)
	}
	if m.self_test_channel_name != nil {
		fields = append(fields, problemtype.FieldSelfTestChannelName)
	}
	if m.judge != nil {
		fields = append(fields, problemtype.FieldJudge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProblemTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case problemtype.FieldSlugName:
		return m.SlugName()
	case problemtype.FieldDisplayName:
		return m.DisplayName()
	case problemtype.FieldDescription:
		return m.Description()
	case problemtype.FieldSubmissionChannelName:
		return m.SubmissionChannelName()
	case problemtype.FieldSelfTestChannelName:
		return m.SelfTestChannelName()
	case problemtype.FieldJudge:
		return m.Judge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProblemTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case problemtype.FieldSlugName:
		return m.OldSlugName(ctx)
	case problemtype.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case problemtype.FieldDescription:
		return m.OldDescription(ctx)
	case problemtype.FieldSubmissionChannelName:
		return m.OldSubmissionChannelName(ctx)
	case problemtype.FieldSelfTestChannelName:
		return m.OldSelfTestChannelName(ctx)
	case problemtype.FieldJudge:
		return m.OldJudge(ctx)
	}
	return nil, fmt.Errorf("unknown ProblemType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case problemtype.FieldSlugName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlugName(v)
		return nil
	case problemtype.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case problemtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case problemtype.FieldSubmissionChannelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmissionChannelName(v)
		return nil
	case problemtype.FieldSelfTestChannelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfTestChannelName(v)
		return nil
	case problemtype.FieldJudge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJudge(v)
		return nil
	}
	return fmt.Errorf("unknown ProblemType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProblemTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProblemTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProblemType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProblemTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProblemTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProblemTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProblemType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProblemTypeMutation) ResetField(name string) error {
	switch name {
	case problemtype.FieldSlugName:
		m.ResetSlugName()
		return nil
	case problemtype.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case problemtype.FieldDescription:
		m.ResetDescription()
		return nil
	case problemtype.FieldSubmissionChannelName:
		m.ResetSubmissionChannelName()
		return nil
	case problemtype.FieldSelfTestChannelName:
		m.ResetSelfTestChannelName()
		return nil
	case problemtype.FieldJudge:
		m.ResetJudge()
		return nil
	}
	return fmt.Errorf("unknown ProblemType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProblemTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.problems != nil {
		edges = append(edges, problemtype.EdgeProblems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProblemTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case problemtype.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.problems))
		for id := range m.problems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProblemTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproblems != nil {
		edges = append(edges, problemtype.EdgeProblems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProblemTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case problemtype.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.removedproblems))
		for id := range m.removedproblems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProblemTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproblems {
		edges = append(edges, problemtype.EdgeProblems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProblemTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case problemtype.EdgeProblems:
		return m.clearedproblems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProblemTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProblemType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProblemTypeMutation) ResetEdge(name string) error {
	switch name {
	case problemtype.EdgeProblems:
		m.ResetProblems()
		return nil
	}
	return fmt.Errorf("unknown ProblemType edge %s", name)
}

// SubmissionMutation represents an operation that mutates the Submission nodes in the graph.
type SubmissionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	code                       *string
	state                      *int16
	addstate                   *int16
	compile_stdout             *string
	compile_stderr             *string
	point                      *int16
	addpoint                   *int16
	create_time                *time.Time
	total_time                 *uint64
	addtotal_time              *int64
	max_memory                 *uint64
	addmax_memory              *int64
	language                   *string
	case_version               *int8
	addcase_version            *int8
	clearedFields              map[string]struct{}
	submission_subtasks        map[int64]struct{}
	removedsubmission_subtasks map[int64]struct{}
	clearedsubmission_subtasks bool
	problems                   *int64
	clearedproblems            bool
	users                      *int64
	clearedusers               bool
	contest_results            map[int]struct{}
	removedcontest_results     map[int]struct{}
	clearedcontest_results     bool
	done                       bool
	oldValue                   func(context.Context) (*Submission, error)
	predicates                 []predicate.Submission
}

var _ ent.Mutation = (*SubmissionMutation)(nil)

// submissionOption allows management of the mutation configuration using functional options.
type submissionOption func(*SubmissionMutation)

// newSubmissionMutation creates new mutation for the Submission entity.
func newSubmissionMutation(c config, op Op, opts ...submissionOption) *SubmissionMutation {
	m := &SubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubmissionID sets the ID field of the mutation.
func withSubmissionID(id int64) submissionOption {
	return func(m *SubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Submission
		)
		m.oldValue = func(ctx context.Context) (*Submission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Submission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubmission sets the old Submission of the mutation.
func withSubmission(node *Submission) submissionOption {
	return func(m *SubmissionMutation) {
		m.oldValue = func(context.Context) (*Submission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Submission entities.
func (m *SubmissionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubmissionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubmissionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Submission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *SubmissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SubmissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SubmissionMutation) ResetCode() {
	m.code = nil
}

// SetState sets the "state" field.
func (m *SubmissionMutation) SetState(i int16) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *SubmissionMutation) State() (r int16, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldState(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *SubmissionMutation) AddState(i int16) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *SubmissionMutation) AddedState() (r int16, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *SubmissionMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCompileStdout sets the "compile_stdout" field.
func (m *SubmissionMutation) SetCompileStdout(s string) {
	m.compile_stdout = &s
}

// CompileStdout returns the value of the "compile_stdout" field in the mutation.
func (m *SubmissionMutation) CompileStdout() (r string, exists bool) {
	v := m.compile_stdout
	if v == nil {
		return
	}
	return *v, true
}

// OldCompileStdout returns the old "compile_stdout" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldCompileStdout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompileStdout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompileStdout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompileStdout: %w", err)
	}
	return oldValue.CompileStdout, nil
}

// ResetCompileStdout resets all changes to the "compile_stdout" field.
func (m *SubmissionMutation) ResetCompileStdout() {
	m.compile_stdout = nil
}

// SetCompileStderr sets the "compile_stderr" field.
func (m *SubmissionMutation) SetCompileStderr(s string) {
	m.compile_stderr = &s
}

// CompileStderr returns the value of the "compile_stderr" field in the mutation.
func (m *SubmissionMutation) CompileStderr() (r string, exists bool) {
	v := m.compile_stderr
	if v == nil {
		return
	}
	return *v, true
}

// OldCompileStderr returns the old "compile_stderr" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldCompileStderr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompileStderr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompileStderr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompileStderr: %w", err)
	}
	return oldValue.CompileStderr, nil
}

// ResetCompileStderr resets all changes to the "compile_stderr" field.
func (m *SubmissionMutation) ResetCompileStderr() {
	m.compile_stderr = nil
}

// SetPoint sets the "point" field.
func (m *SubmissionMutation) SetPoint(i int16) {
	m.point = &i
	m.addpoint = nil
}

// Point returns the value of the "point" field in the mutation.
func (m *SubmissionMutation) Point() (r int16, exists bool) {
	v := m.point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "point" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldPoint(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "point" field.
func (m *SubmissionMutation) AddPoint(i int16) {
	if m.addpoint != nil {
		*m.addpoint += i
	} else {
		m.addpoint = &i
	}
}

// AddedPoint returns the value that was added to the "point" field in this mutation.
func (m *SubmissionMutation) AddedPoint() (r int16, exists bool) {
	v := m.addpoint
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoint resets all changes to the "point" field.
func (m *SubmissionMutation) ResetPoint() {
	m.point = nil
	m.addpoint = nil
}

// SetCreateTime sets the "create_time" field.
func (m *SubmissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubmissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubmissionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetTotalTime sets the "total_time" field.
func (m *SubmissionMutation) SetTotalTime(u uint64) {
	m.total_time = &u
	m.addtotal_time = nil
}

// TotalTime returns the value of the "total_time" field in the mutation.
func (m *SubmissionMutation) TotalTime() (r uint64, exists bool) {
	v := m.total_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTime returns the old "total_time" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldTotalTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTime: %w", err)
	}
	return oldValue.TotalTime, nil
}

// AddTotalTime adds u to the "total_time" field.
func (m *SubmissionMutation) AddTotalTime(u int64) {
	if m.addtotal_time != nil {
		*m.addtotal_time += u
	} else {
		m.addtotal_time = &u
	}
}

// AddedTotalTime returns the value that was added to the "total_time" field in this mutation.
func (m *SubmissionMutation) AddedTotalTime() (r int64, exists bool) {
	v := m.addtotal_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTime resets all changes to the "total_time" field.
func (m *SubmissionMutation) ResetTotalTime() {
	m.total_time = nil
	m.addtotal_time = nil
}

// SetMaxMemory sets the "max_memory" field.
func (m *SubmissionMutation) SetMaxMemory(u uint64) {
	m.max_memory = &u
	m.addmax_memory = nil
}

// MaxMemory returns the value of the "max_memory" field in the mutation.
func (m *SubmissionMutation) MaxMemory() (r uint64, exists bool) {
	v := m.max_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxMemory returns the old "max_memory" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldMaxMemory(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxMemory: %w", err)
	}
	return oldValue.MaxMemory, nil
}

// AddMaxMemory adds u to the "max_memory" field.
func (m *SubmissionMutation) AddMaxMemory(u int64) {
	if m.addmax_memory != nil {
		*m.addmax_memory += u
	} else {
		m.addmax_memory = &u
	}
}

// AddedMaxMemory returns the value that was added to the "max_memory" field in this mutation.
func (m *SubmissionMutation) AddedMaxMemory() (r int64, exists bool) {
	v := m.addmax_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxMemory resets all changes to the "max_memory" field.
func (m *SubmissionMutation) ResetMaxMemory() {
	m.max_memory = nil
	m.addmax_memory = nil
}

// SetLanguage sets the "language" field.
func (m *SubmissionMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SubmissionMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *SubmissionMutation) ResetLanguage() {
	m.language = nil
}

// SetCaseVersion sets the "case_version" field.
func (m *SubmissionMutation) SetCaseVersion(i int8) {
	m.case_version = &i
	m.addcase_version = nil
}

// CaseVersion returns the value of the "case_version" field in the mutation.
func (m *SubmissionMutation) CaseVersion() (r int8, exists bool) {
	v := m.case_version
	if v == nil {
		return
	}
	return *v, true
}

// OldCaseVersion returns the old "case_version" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldCaseVersion(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaseVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaseVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaseVersion: %w", err)
	}
	return oldValue.CaseVersion, nil
}

// AddCaseVersion adds i to the "case_version" field.
func (m *SubmissionMutation) AddCaseVersion(i int8) {
	if m.addcase_version != nil {
		*m.addcase_version += i
	} else {
		m.addcase_version = &i
	}
}

// AddedCaseVersion returns the value that was added to the "case_version" field in this mutation.
func (m *SubmissionMutation) AddedCaseVersion() (r int8, exists bool) {
	v := m.addcase_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaseVersion resets all changes to the "case_version" field.
func (m *SubmissionMutation) ResetCaseVersion() {
	m.case_version = nil
	m.addcase_version = nil
}

// SetProblemID sets the "problem_id" field.
func (m *SubmissionMutation) SetProblemID(i int64) {
	m.problems = &i
}

// ProblemID returns the value of the "problem_id" field in the mutation.
func (m *SubmissionMutation) ProblemID() (r int64, exists bool) {
	v := m.problems
	if v == nil {
		return
	}
	return *v, true
}

// OldProblemID returns the old "problem_id" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldProblemID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProblemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProblemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProblemID: %w", err)
	}
	return oldValue.ProblemID, nil
}

// ResetProblemID resets all changes to the "problem_id" field.
func (m *SubmissionMutation) ResetProblemID() {
	m.problems = nil
}

// SetUserID sets the "user_id" field.
func (m *SubmissionMutation) SetUserID(i int64) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SubmissionMutation) UserID() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Submission entity.
// If the Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SubmissionMutation) ResetUserID() {
	m.users = nil
}

// AddSubmissionSubtaskIDs adds the "submission_subtasks" edge to the SubmissionSubtask entity by ids.
func (m *SubmissionMutation) AddSubmissionSubtaskIDs(ids ...int64) {
	if m.submission_subtasks == nil {
		m.submission_subtasks = make(map[int64]struct{})
	}
	for i := range ids {
		m.submission_subtasks[ids[i]] = struct{}{}
	}
}

// ClearSubmissionSubtasks clears the "submission_subtasks" edge to the SubmissionSubtask entity.
func (m *SubmissionMutation) ClearSubmissionSubtasks() {
	m.clearedsubmission_subtasks = true
}

// SubmissionSubtasksCleared reports if the "submission_subtasks" edge to the SubmissionSubtask entity was cleared.
func (m *SubmissionMutation) SubmissionSubtasksCleared() bool {
	return m.clearedsubmission_subtasks
}

// RemoveSubmissionSubtaskIDs removes the "submission_subtasks" edge to the SubmissionSubtask entity by IDs.
func (m *SubmissionMutation) RemoveSubmissionSubtaskIDs(ids ...int64) {
	if m.removedsubmission_subtasks == nil {
		m.removedsubmission_subtasks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.submission_subtasks, ids[i])
		m.removedsubmission_subtasks[ids[i]] = struct{}{}
	}
}

// RemovedSubmissionSubtasks returns the removed IDs of the "submission_subtasks" edge to the SubmissionSubtask entity.
func (m *SubmissionMutation) RemovedSubmissionSubtasksIDs() (ids []int64) {
	for id := range m.removedsubmission_subtasks {
		ids = append(ids, id)
	}
	return
}

// SubmissionSubtasksIDs returns the "submission_subtasks" edge IDs in the mutation.
func (m *SubmissionMutation) SubmissionSubtasksIDs() (ids []int64) {
	for id := range m.submission_subtasks {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissionSubtasks resets all changes to the "submission_subtasks" edge.
func (m *SubmissionMutation) ResetSubmissionSubtasks() {
	m.submission_subtasks = nil
	m.clearedsubmission_subtasks = false
	m.removedsubmission_subtasks = nil
}

// SetProblemsID sets the "problems" edge to the Problem entity by id.
func (m *SubmissionMutation) SetProblemsID(id int64) {
	m.problems = &id
}

// ClearProblems clears the "problems" edge to the Problem entity.
func (m *SubmissionMutation) ClearProblems() {
	m.clearedproblems = true
	m.clearedFields[submission.FieldProblemID] = struct{}{}
}

// ProblemsCleared reports if the "problems" edge to the Problem entity was cleared.
func (m *SubmissionMutation) ProblemsCleared() bool {
	return m.clearedproblems
}

// ProblemsID returns the "problems" edge ID in the mutation.
func (m *SubmissionMutation) ProblemsID() (id int64, exists bool) {
	if m.problems != nil {
		return *m.problems, true
	}
	return
}

// ProblemsIDs returns the "problems" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProblemsID instead. It exists only for internal usage by the builders.
func (m *SubmissionMutation) ProblemsIDs() (ids []int64) {
	if id := m.problems; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProblems resets all changes to the "problems" edge.
func (m *SubmissionMutation) ResetProblems() {
	m.problems = nil
	m.clearedproblems = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *SubmissionMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *SubmissionMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[submission.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *SubmissionMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *SubmissionMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *SubmissionMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *SubmissionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// AddContestResultIDs adds the "contest_results" edge to the ContestResult entity by ids.
func (m *SubmissionMutation) AddContestResultIDs(ids ...int) {
	if m.contest_results == nil {
		m.contest_results = make(map[int]struct{})
	}
	for i := range ids {
		m.contest_results[ids[i]] = struct{}{}
	}
}

// ClearContestResults clears the "contest_results" edge to the ContestResult entity.
func (m *SubmissionMutation) ClearContestResults() {
	m.clearedcontest_results = true
}

// ContestResultsCleared reports if the "contest_results" edge to the ContestResult entity was cleared.
func (m *SubmissionMutation) ContestResultsCleared() bool {
	return m.clearedcontest_results
}

// RemoveContestResultIDs removes the "contest_results" edge to the ContestResult entity by IDs.
func (m *SubmissionMutation) RemoveContestResultIDs(ids ...int) {
	if m.removedcontest_results == nil {
		m.removedcontest_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contest_results, ids[i])
		m.removedcontest_results[ids[i]] = struct{}{}
	}
}

// RemovedContestResults returns the removed IDs of the "contest_results" edge to the ContestResult entity.
func (m *SubmissionMutation) RemovedContestResultsIDs() (ids []int) {
	for id := range m.removedcontest_results {
		ids = append(ids, id)
	}
	return
}

// ContestResultsIDs returns the "contest_results" edge IDs in the mutation.
func (m *SubmissionMutation) ContestResultsIDs() (ids []int) {
	for id := range m.contest_results {
		ids = append(ids, id)
	}
	return
}

// ResetContestResults resets all changes to the "contest_results" edge.
func (m *SubmissionMutation) ResetContestResults() {
	m.contest_results = nil
	m.clearedcontest_results = false
	m.removedcontest_results = nil
}

// Where appends a list predicates to the SubmissionMutation builder.
func (m *SubmissionMutation) Where(ps ...predicate.Submission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubmissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubmissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Submission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubmissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubmissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Submission).
func (m *SubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubmissionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.code != nil {
		fields = append(fields, submission.FieldCode)
	}
	if m.state != nil {
		fields = append(fields, submission.FieldState)
	}
	if m.compile_stdout != nil {
		fields = append(fields, submission.FieldCompileStdout)
	}
	if m.compile_stderr != nil {
		fields = append(fields, submission.FieldCompileStderr)
	}
	if m.point != nil {
		fields = append(fields, submission.FieldPoint)
	}
	if m.create_time != nil {
		fields = append(fields, submission.FieldCreateTime)
	}
	if m.total_time != nil {
		fields = append(fields, submission.FieldTotalTime)
	}
	if m.max_memory != nil {
		fields = append(fields, submission.FieldMaxMemory)
	}
	if m.language != nil {
		fields = append(fields, submission.FieldLanguage)
	}
	if m.case_version != nil {
		fields = append(fields, submission.FieldCaseVersion)
	}
	if m.problems != nil {
		fields = append(fields, submission.FieldProblemID)
	}
	if m.users != nil {
		fields = append(fields, submission.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case submission.FieldCode:
		return m.Code()
	case submission.FieldState:
		return m.State()
	case submission.FieldCompileStdout:
		return m.CompileStdout()
	case submission.FieldCompileStderr:
		return m.CompileStderr()
	case submission.FieldPoint:
		return m.Point()
	case submission.FieldCreateTime:
		return m.CreateTime()
	case submission.FieldTotalTime:
		return m.TotalTime()
	case submission.FieldMaxMemory:
		return m.MaxMemory()
	case submission.FieldLanguage:
		return m.Language()
	case submission.FieldCaseVersion:
		return m.CaseVersion()
	case submission.FieldProblemID:
		return m.ProblemID()
	case submission.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case submission.FieldCode:
		return m.OldCode(ctx)
	case submission.FieldState:
		return m.OldState(ctx)
	case submission.FieldCompileStdout:
		return m.OldCompileStdout(ctx)
	case submission.FieldCompileStderr:
		return m.OldCompileStderr(ctx)
	case submission.FieldPoint:
		return m.OldPoint(ctx)
	case submission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case submission.FieldTotalTime:
		return m.OldTotalTime(ctx)
	case submission.FieldMaxMemory:
		return m.OldMaxMemory(ctx)
	case submission.FieldLanguage:
		return m.OldLanguage(ctx)
	case submission.FieldCaseVersion:
		return m.OldCaseVersion(ctx)
	case submission.FieldProblemID:
		return m.OldProblemID(ctx)
	case submission.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Submission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case submission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case submission.FieldState:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case submission.FieldCompileStdout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompileStdout(v)
		return nil
	case submission.FieldCompileStderr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompileStderr(v)
		return nil
	case submission.FieldPoint:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case submission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case submission.FieldTotalTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTime(v)
		return nil
	case submission.FieldMaxMemory:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxMemory(v)
		return nil
	case submission.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case submission.FieldCaseVersion:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaseVersion(v)
		return nil
	case submission.FieldProblemID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProblemID(v)
		return nil
	case submission.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Submission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubmissionMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, submission.FieldState)
	}
	if m.addpoint != nil {
		fields = append(fields, submission.FieldPoint)
	}
	if m.addtotal_time != nil {
		fields = append(fields, submission.FieldTotalTime)
	}
	if m.addmax_memory != nil {
		fields = append(fields, submission.FieldMaxMemory)
	}
	if m.addcase_version != nil {
		fields = append(fields, submission.FieldCaseVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case submission.FieldState:
		return m.AddedState()
	case submission.FieldPoint:
		return m.AddedPoint()
	case submission.FieldTotalTime:
		return m.AddedTotalTime()
	case submission.FieldMaxMemory:
		return m.AddedMaxMemory()
	case submission.FieldCaseVersion:
		return m.AddedCaseVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case submission.FieldState:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case submission.FieldPoint:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	case submission.FieldTotalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTime(v)
		return nil
	case submission.FieldMaxMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxMemory(v)
		return nil
	case submission.FieldCaseVersion:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaseVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Submission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubmissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubmissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Submission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubmissionMutation) ResetField(name string) error {
	switch name {
	case submission.FieldCode:
		m.ResetCode()
		return nil
	case submission.FieldState:
		m.ResetState()
		return nil
	case submission.FieldCompileStdout:
		m.ResetCompileStdout()
		return nil
	case submission.FieldCompileStderr:
		m.ResetCompileStderr()
		return nil
	case submission.FieldPoint:
		m.ResetPoint()
		return nil
	case submission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case submission.FieldTotalTime:
		m.ResetTotalTime()
		return nil
	case submission.FieldMaxMemory:
		m.ResetMaxMemory()
		return nil
	case submission.FieldLanguage:
		m.ResetLanguage()
		return nil
	case submission.FieldCaseVersion:
		m.ResetCaseVersion()
		return nil
	case submission.FieldProblemID:
		m.ResetProblemID()
		return nil
	case submission.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Submission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.submission_subtasks != nil {
		edges = append(edges, submission.EdgeSubmissionSubtasks)
	}
	if m.problems != nil {
		edges = append(edges, submission.EdgeProblems)
	}
	if m.users != nil {
		edges = append(edges, submission.EdgeUsers)
	}
	if m.contest_results != nil {
		edges = append(edges, submission.EdgeContestResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case submission.EdgeSubmissionSubtasks:
		ids := make([]ent.Value, 0, len(m.submission_subtasks))
		for id := range m.submission_subtasks {
			ids = append(ids, id)
		}
		return ids
	case submission.EdgeProblems:
		if id := m.problems; id != nil {
			return []ent.Value{*id}
		}
	case submission.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case submission.EdgeContestResults:
		ids := make([]ent.Value, 0, len(m.contest_results))
		for id := range m.contest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubmission_subtasks != nil {
		edges = append(edges, submission.EdgeSubmissionSubtasks)
	}
	if m.removedcontest_results != nil {
		edges = append(edges, submission.EdgeContestResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case submission.EdgeSubmissionSubtasks:
		ids := make([]ent.Value, 0, len(m.removedsubmission_subtasks))
		for id := range m.removedsubmission_subtasks {
			ids = append(ids, id)
		}
		return ids
	case submission.EdgeContestResults:
		ids := make([]ent.Value, 0, len(m.removedcontest_results))
		for id := range m.removedcontest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubmission_subtasks {
		edges = append(edges, submission.EdgeSubmissionSubtasks)
	}
	if m.clearedproblems {
		edges = append(edges, submission.EdgeProblems)
	}
	if m.clearedusers {
		edges = append(edges, submission.EdgeUsers)
	}
	if m.clearedcontest_results {
		edges = append(edges, submission.EdgeContestResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case submission.EdgeSubmissionSubtasks:
		return m.clearedsubmission_subtasks
	case submission.EdgeProblems:
		return m.clearedproblems
	case submission.EdgeUsers:
		return m.clearedusers
	case submission.EdgeContestResults:
		return m.clearedcontest_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubmissionMutation) ClearEdge(name string) error {
	switch name {
	case submission.EdgeProblems:
		m.ClearProblems()
		return nil
	case submission.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Submission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubmissionMutation) ResetEdge(name string) error {
	switch name {
	case submission.EdgeSubmissionSubtasks:
		m.ResetSubmissionSubtasks()
		return nil
	case submission.EdgeProblems:
		m.ResetProblems()
		return nil
	case submission.EdgeUsers:
		m.ResetUsers()
		return nil
	case submission.EdgeContestResults:
		m.ResetContestResults()
		return nil
	}
	return fmt.Errorf("unknown Submission edge %s", name)
}

// SubmissionCaseMutation represents an operation that mutates the SubmissionCase nodes in the graph.
type SubmissionCaseMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	state                      *int16
	addstate                   *int16
	point                      *int16
	addpoint                   *int16
	time                       *uint64
	addtime                    *int64
	memory                     *uint64
	addmemory                  *int64
	stdout                     *string
	stderr                     *string
	clearedFields              map[string]struct{}
	submission_subtasks        *int64
	clearedsubmission_subtasks bool
	done                       bool
	oldValue                   func(context.Context) (*SubmissionCase, error)
	predicates                 []predicate.SubmissionCase
}

var _ ent.Mutation = (*SubmissionCaseMutation)(nil)

// submissioncaseOption allows management of the mutation configuration using functional options.
type submissioncaseOption func(*SubmissionCaseMutation)

// newSubmissionCaseMutation creates new mutation for the SubmissionCase entity.
func newSubmissionCaseMutation(c config, op Op, opts ...submissioncaseOption) *SubmissionCaseMutation {
	m := &SubmissionCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeSubmissionCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubmissionCaseID sets the ID field of the mutation.
func withSubmissionCaseID(id int64) submissioncaseOption {
	return func(m *SubmissionCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *SubmissionCase
		)
		m.oldValue = func(ctx context.Context) (*SubmissionCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubmissionCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubmissionCase sets the old SubmissionCase of the mutation.
func withSubmissionCase(node *SubmissionCase) submissioncaseOption {
	return func(m *SubmissionCaseMutation) {
		m.oldValue = func(context.Context) (*SubmissionCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubmissionCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubmissionCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubmissionCase entities.
func (m *SubmissionCaseMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubmissionCaseMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubmissionCaseMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubmissionCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetState sets the "state" field.
func (m *SubmissionCaseMutation) SetState(i int16) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *SubmissionCaseMutation) State() (r int16, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldState(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *SubmissionCaseMutation) AddState(i int16) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *SubmissionCaseMutation) AddedState() (r int16, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *SubmissionCaseMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetPoint sets the "point" field.
func (m *SubmissionCaseMutation) SetPoint(i int16) {
	m.point = &i
	m.addpoint = nil
}

// Point returns the value of the "point" field in the mutation.
func (m *SubmissionCaseMutation) Point() (r int16, exists bool) {
	v := m.point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "point" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldPoint(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "point" field.
func (m *SubmissionCaseMutation) AddPoint(i int16) {
	if m.addpoint != nil {
		*m.addpoint += i
	} else {
		m.addpoint = &i
	}
}

// AddedPoint returns the value that was added to the "point" field in this mutation.
func (m *SubmissionCaseMutation) AddedPoint() (r int16, exists bool) {
	v := m.addpoint
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoint resets all changes to the "point" field.
func (m *SubmissionCaseMutation) ResetPoint() {
	m.point = nil
	m.addpoint = nil
}

// SetTime sets the "time" field.
func (m *SubmissionCaseMutation) SetTime(u uint64) {
	m.time = &u
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *SubmissionCaseMutation) Time() (r uint64, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds u to the "time" field.
func (m *SubmissionCaseMutation) AddTime(u int64) {
	if m.addtime != nil {
		*m.addtime += u
	} else {
		m.addtime = &u
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *SubmissionCaseMutation) AddedTime() (r int64, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTime resets all changes to the "time" field.
func (m *SubmissionCaseMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
}

// SetMemory sets the "memory" field.
func (m *SubmissionCaseMutation) SetMemory(u uint64) {
	m.memory = &u
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *SubmissionCaseMutation) Memory() (r uint64, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldMemory(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds u to the "memory" field.
func (m *SubmissionCaseMutation) AddMemory(u int64) {
	if m.addmemory != nil {
		*m.addmemory += u
	} else {
		m.addmemory = &u
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *SubmissionCaseMutation) AddedMemory() (r int64, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemory resets all changes to the "memory" field.
func (m *SubmissionCaseMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
}

// SetStdout sets the "stdout" field.
func (m *SubmissionCaseMutation) SetStdout(s string) {
	m.stdout = &s
}

// Stdout returns the value of the "stdout" field in the mutation.
func (m *SubmissionCaseMutation) Stdout() (r string, exists bool) {
	v := m.stdout
	if v == nil {
		return
	}
	return *v, true
}

// OldStdout returns the old "stdout" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldStdout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStdout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStdout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStdout: %w", err)
	}
	return oldValue.Stdout, nil
}

// ResetStdout resets all changes to the "stdout" field.
func (m *SubmissionCaseMutation) ResetStdout() {
	m.stdout = nil
}

// SetStderr sets the "stderr" field.
func (m *SubmissionCaseMutation) SetStderr(s string) {
	m.stderr = &s
}

// Stderr returns the value of the "stderr" field in the mutation.
func (m *SubmissionCaseMutation) Stderr() (r string, exists bool) {
	v := m.stderr
	if v == nil {
		return
	}
	return *v, true
}

// OldStderr returns the old "stderr" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldStderr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStderr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStderr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderr: %w", err)
	}
	return oldValue.Stderr, nil
}

// ResetStderr resets all changes to the "stderr" field.
func (m *SubmissionCaseMutation) ResetStderr() {
	m.stderr = nil
}

// SetSubmissionSubtaskID sets the "submission_subtask_id" field.
func (m *SubmissionCaseMutation) SetSubmissionSubtaskID(i int64) {
	m.submission_subtasks = &i
}

// SubmissionSubtaskID returns the value of the "submission_subtask_id" field in the mutation.
func (m *SubmissionCaseMutation) SubmissionSubtaskID() (r int64, exists bool) {
	v := m.submission_subtasks
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmissionSubtaskID returns the old "submission_subtask_id" field's value of the SubmissionCase entity.
// If the SubmissionCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionCaseMutation) OldSubmissionSubtaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmissionSubtaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmissionSubtaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmissionSubtaskID: %w", err)
	}
	return oldValue.SubmissionSubtaskID, nil
}

// ResetSubmissionSubtaskID resets all changes to the "submission_subtask_id" field.
func (m *SubmissionCaseMutation) ResetSubmissionSubtaskID() {
	m.submission_subtasks = nil
}

// SetSubmissionSubtasksID sets the "submission_subtasks" edge to the SubmissionSubtask entity by id.
func (m *SubmissionCaseMutation) SetSubmissionSubtasksID(id int64) {
	m.submission_subtasks = &id
}

// ClearSubmissionSubtasks clears the "submission_subtasks" edge to the SubmissionSubtask entity.
func (m *SubmissionCaseMutation) ClearSubmissionSubtasks() {
	m.clearedsubmission_subtasks = true
	m.clearedFields[submissioncase.FieldSubmissionSubtaskID] = struct{}{}
}

// SubmissionSubtasksCleared reports if the "submission_subtasks" edge to the SubmissionSubtask entity was cleared.
func (m *SubmissionCaseMutation) SubmissionSubtasksCleared() bool {
	return m.clearedsubmission_subtasks
}

// SubmissionSubtasksID returns the "submission_subtasks" edge ID in the mutation.
func (m *SubmissionCaseMutation) SubmissionSubtasksID() (id int64, exists bool) {
	if m.submission_subtasks != nil {
		return *m.submission_subtasks, true
	}
	return
}

// SubmissionSubtasksIDs returns the "submission_subtasks" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubmissionSubtasksID instead. It exists only for internal usage by the builders.
func (m *SubmissionCaseMutation) SubmissionSubtasksIDs() (ids []int64) {
	if id := m.submission_subtasks; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubmissionSubtasks resets all changes to the "submission_subtasks" edge.
func (m *SubmissionCaseMutation) ResetSubmissionSubtasks() {
	m.submission_subtasks = nil
	m.clearedsubmission_subtasks = false
}

// Where appends a list predicates to the SubmissionCaseMutation builder.
func (m *SubmissionCaseMutation) Where(ps ...predicate.SubmissionCase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubmissionCaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubmissionCaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubmissionCase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubmissionCaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubmissionCaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubmissionCase).
func (m *SubmissionCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubmissionCaseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.state != nil {
		fields = append(fields, submissioncase.FieldState)
	}
	if m.point != nil {
		fields = append(fields, submissioncase.FieldPoint)
	}
	if m.time != nil {
		fields = append(fields, submissioncase.FieldTime)
	}
	if m.memory != nil {
		fields = append(fields, submissioncase.FieldMemory)
	}
	if m.stdout != nil {
		fields = append(fields, submissioncase.FieldStdout)
	}
	if m.stderr != nil {
		fields = append(fields, submissioncase.FieldStderr)
	}
	if m.submission_subtasks != nil {
		fields = append(fields, submissioncase.FieldSubmissionSubtaskID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubmissionCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case submissioncase.FieldState:
		return m.State()
	case submissioncase.FieldPoint:
		return m.Point()
	case submissioncase.FieldTime:
		return m.Time()
	case submissioncase.FieldMemory:
		return m.Memory()
	case submissioncase.FieldStdout:
		return m.Stdout()
	case submissioncase.FieldStderr:
		return m.Stderr()
	case submissioncase.FieldSubmissionSubtaskID:
		return m.SubmissionSubtaskID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubmissionCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case submissioncase.FieldState:
		return m.OldState(ctx)
	case submissioncase.FieldPoint:
		return m.OldPoint(ctx)
	case submissioncase.FieldTime:
		return m.OldTime(ctx)
	case submissioncase.FieldMemory:
		return m.OldMemory(ctx)
	case submissioncase.FieldStdout:
		return m.OldStdout(ctx)
	case submissioncase.FieldStderr:
		return m.OldStderr(ctx)
	case submissioncase.FieldSubmissionSubtaskID:
		return m.OldSubmissionSubtaskID(ctx)
	}
	return nil, fmt.Errorf("unknown SubmissionCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubmissionCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case submissioncase.FieldState:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case submissioncase.FieldPoint:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case submissioncase.FieldTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case submissioncase.FieldMemory:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case submissioncase.FieldStdout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStdout(v)
		return nil
	case submissioncase.FieldStderr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderr(v)
		return nil
	case submissioncase.FieldSubmissionSubtaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmissionSubtaskID(v)
		return nil
	}
	return fmt.Errorf("unknown SubmissionCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubmissionCaseMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, submissioncase.FieldState)
	}
	if m.addpoint != nil {
		fields = append(fields, submissioncase.FieldPoint)
	}
	if m.addtime != nil {
		fields = append(fields, submissioncase.FieldTime)
	}
	if m.addmemory != nil {
		fields = append(fields, submissioncase.FieldMemory)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubmissionCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case submissioncase.FieldState:
		return m.AddedState()
	case submissioncase.FieldPoint:
		return m.AddedPoint()
	case submissioncase.FieldTime:
		return m.AddedTime()
	case submissioncase.FieldMemory:
		return m.AddedMemory()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubmissionCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case submissioncase.FieldState:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case submissioncase.FieldPoint:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	case submissioncase.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	case submissioncase.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	}
	return fmt.Errorf("unknown SubmissionCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubmissionCaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubmissionCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubmissionCaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubmissionCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubmissionCaseMutation) ResetField(name string) error {
	switch name {
	case submissioncase.FieldState:
		m.ResetState()
		return nil
	case submissioncase.FieldPoint:
		m.ResetPoint()
		return nil
	case submissioncase.FieldTime:
		m.ResetTime()
		return nil
	case submissioncase.FieldMemory:
		m.ResetMemory()
		return nil
	case submissioncase.FieldStdout:
		m.ResetStdout()
		return nil
	case submissioncase.FieldStderr:
		m.ResetStderr()
		return nil
	case submissioncase.FieldSubmissionSubtaskID:
		m.ResetSubmissionSubtaskID()
		return nil
	}
	return fmt.Errorf("unknown SubmissionCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubmissionCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.submission_subtasks != nil {
		edges = append(edges, submissioncase.EdgeSubmissionSubtasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubmissionCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case submissioncase.EdgeSubmissionSubtasks:
		if id := m.submission_subtasks; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubmissionCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubmissionCaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubmissionCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubmission_subtasks {
		edges = append(edges, submissioncase.EdgeSubmissionSubtasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubmissionCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case submissioncase.EdgeSubmissionSubtasks:
		return m.clearedsubmission_subtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubmissionCaseMutation) ClearEdge(name string) error {
	switch name {
	case submissioncase.EdgeSubmissionSubtasks:
		m.ClearSubmissionSubtasks()
		return nil
	}
	return fmt.Errorf("unknown SubmissionCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubmissionCaseMutation) ResetEdge(name string) error {
	switch name {
	case submissioncase.EdgeSubmissionSubtasks:
		m.ResetSubmissionSubtasks()
		return nil
	}
	return fmt.Errorf("unknown SubmissionCase edge %s", name)
}

// SubmissionSubtaskMutation represents an operation that mutates the SubmissionSubtask nodes in the graph.
type SubmissionSubtaskMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	state                   *int16
	addstate                *int16
	point                   *int16
	addpoint                *int16
	total_time              *uint64
	addtotal_time           *int64
	max_memory              *uint64
	addmax_memory           *int64
	clearedFields           map[string]struct{}
	submission_cases        map[int64]struct{}
	removedsubmission_cases map[int64]struct{}
	clearedsubmission_cases bool
	submissions             *int64
	clearedsubmissions      bool
	done                    bool
	oldValue                func(context.Context) (*SubmissionSubtask, error)
	predicates              []predicate.SubmissionSubtask
}

var _ ent.Mutation = (*SubmissionSubtaskMutation)(nil)

// submissionsubtaskOption allows management of the mutation configuration using functional options.
type submissionsubtaskOption func(*SubmissionSubtaskMutation)

// newSubmissionSubtaskMutation creates new mutation for the SubmissionSubtask entity.
func newSubmissionSubtaskMutation(c config, op Op, opts ...submissionsubtaskOption) *SubmissionSubtaskMutation {
	m := &SubmissionSubtaskMutation{
		config:        c,
		op:            op,
		typ:           TypeSubmissionSubtask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubmissionSubtaskID sets the ID field of the mutation.
func withSubmissionSubtaskID(id int64) submissionsubtaskOption {
	return func(m *SubmissionSubtaskMutation) {
		var (
			err   error
			once  sync.Once
			value *SubmissionSubtask
		)
		m.oldValue = func(ctx context.Context) (*SubmissionSubtask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubmissionSubtask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubmissionSubtask sets the old SubmissionSubtask of the mutation.
func withSubmissionSubtask(node *SubmissionSubtask) submissionsubtaskOption {
	return func(m *SubmissionSubtaskMutation) {
		m.oldValue = func(context.Context) (*SubmissionSubtask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubmissionSubtaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubmissionSubtaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubmissionSubtask entities.
func (m *SubmissionSubtaskMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubmissionSubtaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubmissionSubtaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubmissionSubtask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetState sets the "state" field.
func (m *SubmissionSubtaskMutation) SetState(i int16) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *SubmissionSubtaskMutation) State() (r int16, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the SubmissionSubtask entity.
// If the SubmissionSubtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionSubtaskMutation) OldState(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *SubmissionSubtaskMutation) AddState(i int16) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *SubmissionSubtaskMutation) AddedState() (r int16, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *SubmissionSubtaskMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetPoint sets the "point" field.
func (m *SubmissionSubtaskMutation) SetPoint(i int16) {
	m.point = &i
	m.addpoint = nil
}

// Point returns the value of the "point" field in the mutation.
func (m *SubmissionSubtaskMutation) Point() (r int16, exists bool) {
	v := m.point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "point" field's value of the SubmissionSubtask entity.
// If the SubmissionSubtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionSubtaskMutation) OldPoint(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "point" field.
func (m *SubmissionSubtaskMutation) AddPoint(i int16) {
	if m.addpoint != nil {
		*m.addpoint += i
	} else {
		m.addpoint = &i
	}
}

// AddedPoint returns the value that was added to the "point" field in this mutation.
func (m *SubmissionSubtaskMutation) AddedPoint() (r int16, exists bool) {
	v := m.addpoint
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoint resets all changes to the "point" field.
func (m *SubmissionSubtaskMutation) ResetPoint() {
	m.point = nil
	m.addpoint = nil
}

// SetTotalTime sets the "total_time" field.
func (m *SubmissionSubtaskMutation) SetTotalTime(u uint64) {
	m.total_time = &u
	m.addtotal_time = nil
}

// TotalTime returns the value of the "total_time" field in the mutation.
func (m *SubmissionSubtaskMutation) TotalTime() (r uint64, exists bool) {
	v := m.total_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTime returns the old "total_time" field's value of the SubmissionSubtask entity.
// If the SubmissionSubtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionSubtaskMutation) OldTotalTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTime: %w", err)
	}
	return oldValue.TotalTime, nil
}

// AddTotalTime adds u to the "total_time" field.
func (m *SubmissionSubtaskMutation) AddTotalTime(u int64) {
	if m.addtotal_time != nil {
		*m.addtotal_time += u
	} else {
		m.addtotal_time = &u
	}
}

// AddedTotalTime returns the value that was added to the "total_time" field in this mutation.
func (m *SubmissionSubtaskMutation) AddedTotalTime() (r int64, exists bool) {
	v := m.addtotal_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTime resets all changes to the "total_time" field.
func (m *SubmissionSubtaskMutation) ResetTotalTime() {
	m.total_time = nil
	m.addtotal_time = nil
}

// SetMaxMemory sets the "max_memory" field.
func (m *SubmissionSubtaskMutation) SetMaxMemory(u uint64) {
	m.max_memory = &u
	m.addmax_memory = nil
}

// MaxMemory returns the value of the "max_memory" field in the mutation.
func (m *SubmissionSubtaskMutation) MaxMemory() (r uint64, exists bool) {
	v := m.max_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxMemory returns the old "max_memory" field's value of the SubmissionSubtask entity.
// If the SubmissionSubtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionSubtaskMutation) OldMaxMemory(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxMemory: %w", err)
	}
	return oldValue.MaxMemory, nil
}

// AddMaxMemory adds u to the "max_memory" field.
func (m *SubmissionSubtaskMutation) AddMaxMemory(u int64) {
	if m.addmax_memory != nil {
		*m.addmax_memory += u
	} else {
		m.addmax_memory = &u
	}
}

// AddedMaxMemory returns the value that was added to the "max_memory" field in this mutation.
func (m *SubmissionSubtaskMutation) AddedMaxMemory() (r int64, exists bool) {
	v := m.addmax_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxMemory resets all changes to the "max_memory" field.
func (m *SubmissionSubtaskMutation) ResetMaxMemory() {
	m.max_memory = nil
	m.addmax_memory = nil
}

// SetSubmissionID sets the "submission_id" field.
func (m *SubmissionSubtaskMutation) SetSubmissionID(i int64) {
	m.submissions = &i
}

// SubmissionID returns the value of the "submission_id" field in the mutation.
func (m *SubmissionSubtaskMutation) SubmissionID() (r int64, exists bool) {
	v := m.submissions
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmissionID returns the old "submission_id" field's value of the SubmissionSubtask entity.
// If the SubmissionSubtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubmissionSubtaskMutation) OldSubmissionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmissionID: %w", err)
	}
	return oldValue.SubmissionID, nil
}

// ResetSubmissionID resets all changes to the "submission_id" field.
func (m *SubmissionSubtaskMutation) ResetSubmissionID() {
	m.submissions = nil
}

// AddSubmissionCaseIDs adds the "submission_cases" edge to the SubmissionCase entity by ids.
func (m *SubmissionSubtaskMutation) AddSubmissionCaseIDs(ids ...int64) {
	if m.submission_cases == nil {
		m.submission_cases = make(map[int64]struct{})
	}
	for i := range ids {
		m.submission_cases[ids[i]] = struct{}{}
	}
}

// ClearSubmissionCases clears the "submission_cases" edge to the SubmissionCase entity.
func (m *SubmissionSubtaskMutation) ClearSubmissionCases() {
	m.clearedsubmission_cases = true
}

// SubmissionCasesCleared reports if the "submission_cases" edge to the SubmissionCase entity was cleared.
func (m *SubmissionSubtaskMutation) SubmissionCasesCleared() bool {
	return m.clearedsubmission_cases
}

// RemoveSubmissionCaseIDs removes the "submission_cases" edge to the SubmissionCase entity by IDs.
func (m *SubmissionSubtaskMutation) RemoveSubmissionCaseIDs(ids ...int64) {
	if m.removedsubmission_cases == nil {
		m.removedsubmission_cases = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.submission_cases, ids[i])
		m.removedsubmission_cases[ids[i]] = struct{}{}
	}
}

// RemovedSubmissionCases returns the removed IDs of the "submission_cases" edge to the SubmissionCase entity.
func (m *SubmissionSubtaskMutation) RemovedSubmissionCasesIDs() (ids []int64) {
	for id := range m.removedsubmission_cases {
		ids = append(ids, id)
	}
	return
}

// SubmissionCasesIDs returns the "submission_cases" edge IDs in the mutation.
func (m *SubmissionSubtaskMutation) SubmissionCasesIDs() (ids []int64) {
	for id := range m.submission_cases {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissionCases resets all changes to the "submission_cases" edge.
func (m *SubmissionSubtaskMutation) ResetSubmissionCases() {
	m.submission_cases = nil
	m.clearedsubmission_cases = false
	m.removedsubmission_cases = nil
}

// SetSubmissionsID sets the "submissions" edge to the Submission entity by id.
func (m *SubmissionSubtaskMutation) SetSubmissionsID(id int64) {
	m.submissions = &id
}

// ClearSubmissions clears the "submissions" edge to the Submission entity.
func (m *SubmissionSubtaskMutation) ClearSubmissions() {
	m.clearedsubmissions = true
	m.clearedFields[submissionsubtask.FieldSubmissionID] = struct{}{}
}

// SubmissionsCleared reports if the "submissions" edge to the Submission entity was cleared.
func (m *SubmissionSubtaskMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// SubmissionsID returns the "submissions" edge ID in the mutation.
func (m *SubmissionSubtaskMutation) SubmissionsID() (id int64, exists bool) {
	if m.submissions != nil {
		return *m.submissions, true
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubmissionsID instead. It exists only for internal usage by the builders.
func (m *SubmissionSubtaskMutation) SubmissionsIDs() (ids []int64) {
	if id := m.submissions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *SubmissionSubtaskMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
}

// Where appends a list predicates to the SubmissionSubtaskMutation builder.
func (m *SubmissionSubtaskMutation) Where(ps ...predicate.SubmissionSubtask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubmissionSubtaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubmissionSubtaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubmissionSubtask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubmissionSubtaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubmissionSubtaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubmissionSubtask).
func (m *SubmissionSubtaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubmissionSubtaskMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.state != nil {
		fields = append(fields, submissionsubtask.FieldState)
	}
	if m.point != nil {
		fields = append(fields, submissionsubtask.FieldPoint)
	}
	if m.total_time != nil {
		fields = append(fields, submissionsubtask.FieldTotalTime)
	}
	if m.max_memory != nil {
		fields = append(fields, submissionsubtask.FieldMaxMemory)
	}
	if m.submissions != nil {
		fields = append(fields, submissionsubtask.FieldSubmissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubmissionSubtaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case submissionsubtask.FieldState:
		return m.State()
	case submissionsubtask.FieldPoint:
		return m.Point()
	case submissionsubtask.FieldTotalTime:
		return m.TotalTime()
	case submissionsubtask.FieldMaxMemory:
		return m.MaxMemory()
	case submissionsubtask.FieldSubmissionID:
		return m.SubmissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubmissionSubtaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case submissionsubtask.FieldState:
		return m.OldState(ctx)
	case submissionsubtask.FieldPoint:
		return m.OldPoint(ctx)
	case submissionsubtask.FieldTotalTime:
		return m.OldTotalTime(ctx)
	case submissionsubtask.FieldMaxMemory:
		return m.OldMaxMemory(ctx)
	case submissionsubtask.FieldSubmissionID:
		return m.OldSubmissionID(ctx)
	}
	return nil, fmt.Errorf("unknown SubmissionSubtask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubmissionSubtaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case submissionsubtask.FieldState:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case submissionsubtask.FieldPoint:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case submissionsubtask.FieldTotalTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTime(v)
		return nil
	case submissionsubtask.FieldMaxMemory:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxMemory(v)
		return nil
	case submissionsubtask.FieldSubmissionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmissionID(v)
		return nil
	}
	return fmt.Errorf("unknown SubmissionSubtask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubmissionSubtaskMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, submissionsubtask.FieldState)
	}
	if m.addpoint != nil {
		fields = append(fields, submissionsubtask.FieldPoint)
	}
	if m.addtotal_time != nil {
		fields = append(fields, submissionsubtask.FieldTotalTime)
	}
	if m.addmax_memory != nil {
		fields = append(fields, submissionsubtask.FieldMaxMemory)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubmissionSubtaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case submissionsubtask.FieldState:
		return m.AddedState()
	case submissionsubtask.FieldPoint:
		return m.AddedPoint()
	case submissionsubtask.FieldTotalTime:
		return m.AddedTotalTime()
	case submissionsubtask.FieldMaxMemory:
		return m.AddedMaxMemory()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubmissionSubtaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case submissionsubtask.FieldState:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case submissionsubtask.FieldPoint:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	case submissionsubtask.FieldTotalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTime(v)
		return nil
	case submissionsubtask.FieldMaxMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxMemory(v)
		return nil
	}
	return fmt.Errorf("unknown SubmissionSubtask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubmissionSubtaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubmissionSubtaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubmissionSubtaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubmissionSubtask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubmissionSubtaskMutation) ResetField(name string) error {
	switch name {
	case submissionsubtask.FieldState:
		m.ResetState()
		return nil
	case submissionsubtask.FieldPoint:
		m.ResetPoint()
		return nil
	case submissionsubtask.FieldTotalTime:
		m.ResetTotalTime()
		return nil
	case submissionsubtask.FieldMaxMemory:
		m.ResetMaxMemory()
		return nil
	case submissionsubtask.FieldSubmissionID:
		m.ResetSubmissionID()
		return nil
	}
	return fmt.Errorf("unknown SubmissionSubtask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubmissionSubtaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.submission_cases != nil {
		edges = append(edges, submissionsubtask.EdgeSubmissionCases)
	}
	if m.submissions != nil {
		edges = append(edges, submissionsubtask.EdgeSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubmissionSubtaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case submissionsubtask.EdgeSubmissionCases:
		ids := make([]ent.Value, 0, len(m.submission_cases))
		for id := range m.submission_cases {
			ids = append(ids, id)
		}
		return ids
	case submissionsubtask.EdgeSubmissions:
		if id := m.submissions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubmissionSubtaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubmission_cases != nil {
		edges = append(edges, submissionsubtask.EdgeSubmissionCases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubmissionSubtaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case submissionsubtask.EdgeSubmissionCases:
		ids := make([]ent.Value, 0, len(m.removedsubmission_cases))
		for id := range m.removedsubmission_cases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubmissionSubtaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubmission_cases {
		edges = append(edges, submissionsubtask.EdgeSubmissionCases)
	}
	if m.clearedsubmissions {
		edges = append(edges, submissionsubtask.EdgeSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubmissionSubtaskMutation) EdgeCleared(name string) bool {
	switch name {
	case submissionsubtask.EdgeSubmissionCases:
		return m.clearedsubmission_cases
	case submissionsubtask.EdgeSubmissions:
		return m.clearedsubmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubmissionSubtaskMutation) ClearEdge(name string) error {
	switch name {
	case submissionsubtask.EdgeSubmissions:
		m.ClearSubmissions()
		return nil
	}
	return fmt.Errorf("unknown SubmissionSubtask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubmissionSubtaskMutation) ResetEdge(name string) error {
	switch name {
	case submissionsubtask.EdgeSubmissionCases:
		m.ResetSubmissionCases()
		return nil
	case submissionsubtask.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	}
	return fmt.Errorf("unknown SubmissionSubtask edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	username               *string
	password               *string
	salt                   *string
	state                  *user.State
	clearedFields          map[string]struct{}
	submission             map[int64]struct{}
	removedsubmission      map[int64]struct{}
	clearedsubmission      bool
	login_sessions         map[int64]struct{}
	removedlogin_sessions  map[int64]struct{}
	clearedlogin_sessions  bool
	owned_problems         map[int64]struct{}
	removedowned_problems  map[int64]struct{}
	clearedowned_problems  bool
	groups                 map[int64]struct{}
	removedgroups          map[int64]struct{}
	clearedgroups          bool
	contest_results        map[int]struct{}
	removedcontest_results map[int]struct{}
	clearedcontest_results bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetSalt sets the "salt" field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
}

// SetState sets the "state" field.
func (m *UserMutation) SetState(u user.State) {
	m.state = &u
}

// State returns the value of the "state" field in the mutation.
func (m *UserMutation) State() (r user.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldState(ctx context.Context) (v user.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *UserMutation) ResetState() {
	m.state = nil
}

// AddSubmissionIDs adds the "submission" edge to the Submission entity by ids.
func (m *UserMutation) AddSubmissionIDs(ids ...int64) {
	if m.submission == nil {
		m.submission = make(map[int64]struct{})
	}
	for i := range ids {
		m.submission[ids[i]] = struct{}{}
	}
}

// ClearSubmission clears the "submission" edge to the Submission entity.
func (m *UserMutation) ClearSubmission() {
	m.clearedsubmission = true
}

// SubmissionCleared reports if the "submission" edge to the Submission entity was cleared.
func (m *UserMutation) SubmissionCleared() bool {
	return m.clearedsubmission
}

// RemoveSubmissionIDs removes the "submission" edge to the Submission entity by IDs.
func (m *UserMutation) RemoveSubmissionIDs(ids ...int64) {
	if m.removedsubmission == nil {
		m.removedsubmission = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.submission, ids[i])
		m.removedsubmission[ids[i]] = struct{}{}
	}
}

// RemovedSubmission returns the removed IDs of the "submission" edge to the Submission entity.
func (m *UserMutation) RemovedSubmissionIDs() (ids []int64) {
	for id := range m.removedsubmission {
		ids = append(ids, id)
	}
	return
}

// SubmissionIDs returns the "submission" edge IDs in the mutation.
func (m *UserMutation) SubmissionIDs() (ids []int64) {
	for id := range m.submission {
		ids = append(ids, id)
	}
	return
}

// ResetSubmission resets all changes to the "submission" edge.
func (m *UserMutation) ResetSubmission() {
	m.submission = nil
	m.clearedsubmission = false
	m.removedsubmission = nil
}

// AddLoginSessionIDs adds the "login_sessions" edge to the LoginSession entity by ids.
func (m *UserMutation) AddLoginSessionIDs(ids ...int64) {
	if m.login_sessions == nil {
		m.login_sessions = make(map[int64]struct{})
	}
	for i := range ids {
		m.login_sessions[ids[i]] = struct{}{}
	}
}

// ClearLoginSessions clears the "login_sessions" edge to the LoginSession entity.
func (m *UserMutation) ClearLoginSessions() {
	m.clearedlogin_sessions = true
}

// LoginSessionsCleared reports if the "login_sessions" edge to the LoginSession entity was cleared.
func (m *UserMutation) LoginSessionsCleared() bool {
	return m.clearedlogin_sessions
}

// RemoveLoginSessionIDs removes the "login_sessions" edge to the LoginSession entity by IDs.
func (m *UserMutation) RemoveLoginSessionIDs(ids ...int64) {
	if m.removedlogin_sessions == nil {
		m.removedlogin_sessions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.login_sessions, ids[i])
		m.removedlogin_sessions[ids[i]] = struct{}{}
	}
}

// RemovedLoginSessions returns the removed IDs of the "login_sessions" edge to the LoginSession entity.
func (m *UserMutation) RemovedLoginSessionsIDs() (ids []int64) {
	for id := range m.removedlogin_sessions {
		ids = append(ids, id)
	}
	return
}

// LoginSessionsIDs returns the "login_sessions" edge IDs in the mutation.
func (m *UserMutation) LoginSessionsIDs() (ids []int64) {
	for id := range m.login_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetLoginSessions resets all changes to the "login_sessions" edge.
func (m *UserMutation) ResetLoginSessions() {
	m.login_sessions = nil
	m.clearedlogin_sessions = false
	m.removedlogin_sessions = nil
}

// AddOwnedProblemIDs adds the "owned_problems" edge to the Problem entity by ids.
func (m *UserMutation) AddOwnedProblemIDs(ids ...int64) {
	if m.owned_problems == nil {
		m.owned_problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.owned_problems[ids[i]] = struct{}{}
	}
}

// ClearOwnedProblems clears the "owned_problems" edge to the Problem entity.
func (m *UserMutation) ClearOwnedProblems() {
	m.clearedowned_problems = true
}

// OwnedProblemsCleared reports if the "owned_problems" edge to the Problem entity was cleared.
func (m *UserMutation) OwnedProblemsCleared() bool {
	return m.clearedowned_problems
}

// RemoveOwnedProblemIDs removes the "owned_problems" edge to the Problem entity by IDs.
func (m *UserMutation) RemoveOwnedProblemIDs(ids ...int64) {
	if m.removedowned_problems == nil {
		m.removedowned_problems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.owned_problems, ids[i])
		m.removedowned_problems[ids[i]] = struct{}{}
	}
}

// RemovedOwnedProblems returns the removed IDs of the "owned_problems" edge to the Problem entity.
func (m *UserMutation) RemovedOwnedProblemsIDs() (ids []int64) {
	for id := range m.removedowned_problems {
		ids = append(ids, id)
	}
	return
}

// OwnedProblemsIDs returns the "owned_problems" edge IDs in the mutation.
func (m *UserMutation) OwnedProblemsIDs() (ids []int64) {
	for id := range m.owned_problems {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedProblems resets all changes to the "owned_problems" edge.
func (m *UserMutation) ResetOwnedProblems() {
	m.owned_problems = nil
	m.clearedowned_problems = false
	m.removedowned_problems = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *UserMutation) AddGroupIDs(ids ...int64) {
	if m.groups == nil {
		m.groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveGroupIDs(ids ...int64) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *UserMutation) RemovedGroupsIDs() (ids []int64) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *UserMutation) GroupsIDs() (ids []int64) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddContestResultIDs adds the "contest_results" edge to the ContestResult entity by ids.
func (m *UserMutation) AddContestResultIDs(ids ...int) {
	if m.contest_results == nil {
		m.contest_results = make(map[int]struct{})
	}
	for i := range ids {
		m.contest_results[ids[i]] = struct{}{}
	}
}

// ClearContestResults clears the "contest_results" edge to the ContestResult entity.
func (m *UserMutation) ClearContestResults() {
	m.clearedcontest_results = true
}

// ContestResultsCleared reports if the "contest_results" edge to the ContestResult entity was cleared.
func (m *UserMutation) ContestResultsCleared() bool {
	return m.clearedcontest_results
}

// RemoveContestResultIDs removes the "contest_results" edge to the ContestResult entity by IDs.
func (m *UserMutation) RemoveContestResultIDs(ids ...int) {
	if m.removedcontest_results == nil {
		m.removedcontest_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contest_results, ids[i])
		m.removedcontest_results[ids[i]] = struct{}{}
	}
}

// RemovedContestResults returns the removed IDs of the "contest_results" edge to the ContestResult entity.
func (m *UserMutation) RemovedContestResultsIDs() (ids []int) {
	for id := range m.removedcontest_results {
		ids = append(ids, id)
	}
	return
}

// ContestResultsIDs returns the "contest_results" edge IDs in the mutation.
func (m *UserMutation) ContestResultsIDs() (ids []int) {
	for id := range m.contest_results {
		ids = append(ids, id)
	}
	return
}

// ResetContestResults resets all changes to the "contest_results" edge.
func (m *UserMutation) ResetContestResults() {
	m.contest_results = nil
	m.clearedcontest_results = false
	m.removedcontest_results = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.state != nil {
		fields = append(fields, user.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldState:
		v, ok := value.(user.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.submission != nil {
		edges = append(edges, user.EdgeSubmission)
	}
	if m.login_sessions != nil {
		edges = append(edges, user.EdgeLoginSessions)
	}
	if m.owned_problems != nil {
		edges = append(edges, user.EdgeOwnedProblems)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.contest_results != nil {
		edges = append(edges, user.EdgeContestResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSubmission:
		ids := make([]ent.Value, 0, len(m.submission))
		for id := range m.submission {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginSessions:
		ids := make([]ent.Value, 0, len(m.login_sessions))
		for id := range m.login_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedProblems:
		ids := make([]ent.Value, 0, len(m.owned_problems))
		for id := range m.owned_problems {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContestResults:
		ids := make([]ent.Value, 0, len(m.contest_results))
		for id := range m.contest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedsubmission != nil {
		edges = append(edges, user.EdgeSubmission)
	}
	if m.removedlogin_sessions != nil {
		edges = append(edges, user.EdgeLoginSessions)
	}
	if m.removedowned_problems != nil {
		edges = append(edges, user.EdgeOwnedProblems)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.removedcontest_results != nil {
		edges = append(edges, user.EdgeContestResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSubmission:
		ids := make([]ent.Value, 0, len(m.removedsubmission))
		for id := range m.removedsubmission {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginSessions:
		ids := make([]ent.Value, 0, len(m.removedlogin_sessions))
		for id := range m.removedlogin_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedProblems:
		ids := make([]ent.Value, 0, len(m.removedowned_problems))
		for id := range m.removedowned_problems {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContestResults:
		ids := make([]ent.Value, 0, len(m.removedcontest_results))
		for id := range m.removedcontest_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsubmission {
		edges = append(edges, user.EdgeSubmission)
	}
	if m.clearedlogin_sessions {
		edges = append(edges, user.EdgeLoginSessions)
	}
	if m.clearedowned_problems {
		edges = append(edges, user.EdgeOwnedProblems)
	}
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	if m.clearedcontest_results {
		edges = append(edges, user.EdgeContestResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSubmission:
		return m.clearedsubmission
	case user.EdgeLoginSessions:
		return m.clearedlogin_sessions
	case user.EdgeOwnedProblems:
		return m.clearedowned_problems
	case user.EdgeGroups:
		return m.clearedgroups
	case user.EdgeContestResults:
		return m.clearedcontest_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSubmission:
		m.ResetSubmission()
		return nil
	case user.EdgeLoginSessions:
		m.ResetLoginSessions()
		return nil
	case user.EdgeOwnedProblems:
		m.ResetOwnedProblems()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	case user.EdgeContestResults:
		m.ResetContestResults()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
